{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./p5.cv.utils.js","webpack:///./p5.cv.utilities.js","webpack:///./p5.cv.helpers.js","webpack:///./p5.cv.wrappers.js","webpack:///./p5.cv.tracker.js","webpack:///./p5.cv.running_background.js","webpack:///./p5.cv.object_finder.js","webpack:///./p5.cv.flow.js","webpack:///./p5.cv.contour_finder.js","webpack:///./app.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","p5","cv","loadOpenCV","onRuntimeInitialized","isReady","onComplete","createFileFromUrl","path","url","callback","request","XMLHttpRequest","open","responseType","onload","ev","data","readyState","status","Uint8Array","response","FS_createDataFile","send","loadImageToCanvas","cavansId","canvas","document","getElementById","ctx","getContext","img","Image","crossOrigin","width","height","drawImage","src","registerMethod","getWidth","sourceMat","cols","getHeight","rows","getAllocated","getDepthForType","cvImageType","CV_MAT_DEPTH","getDepthForMat","depth","getDepthForImage","CV_8UC4","CV_8UC","channels","CV_8UC1","CV_8UC2","CV_8UC3","CV_8SC","CV_8SC1","CV_8SC2","CV_8SC3","CV_8SC4","CV_16UC","CV_16UC1","CV_16UC2","CV_16UC3","CV_16UC4","CV_16SC","CV_16SC1","CV_16SC2","CV_16SC3","CV_16SC4","CV_32SC","CV_32SC1","CV_32SC2","CV_32SC3","CV_32SC4","CV_32FC","CV_32FC1","CV_32FC2","CV_32FC3","CV_32FC4","CV_64FC","CV_64FC1","CV_64FC2","CV_64FC3","CV_64FC4","CV_CN_MAX","CV_CN_SHIFT","CV_DEPTH_MAX","CV_MAT_CN_MASK","CV_MAT_CN","flags","CV_MAT_DEPTH_MASK","CV_MAKETYPE","cn","getCvImageType","cvDepth","CV_8U","getCvImageTypeForImage","getChannelsForType","getChannelsForImage","getChannelsForMat","copyTo","destinationMat","alpha","type","getMaxVal","convertTo","copy","dstDepth","allocate","cvType","imitateWithType","mirror","original","mirrorCvImageType","ow","oh","imitate","getMaxValForDepth","CV_16U","CV_8S","CV_16S","CV_32S","CV_32F","CV_64F","getMaxValForMat","mat","getColorConversionTypes","types","indexOf","push","getTargetChannelsFromCode","conversionCode","COLOR_RGB2RGBA","COLOR_RGBA2RGB","COLOR_RGB2BGRA","COLOR_RGBA2BGR","COLOR_BGR2RGB","COLOR_BGRA2RGBA","COLOR_BGR2GRAY","COLOR_RGB2GRAY","COLOR_GRAY2RGB","COLOR_GRAY2RGBA","COLOR_BGRA2GRAY","COLOR_RGBA2GRAY","COLOR_BGR5652BGR","COLOR_BGR5652RGB","COLOR_BGR5652BGRA","COLOR_BGR5652RGBA","COLOR_BGR5652GRAY","COLOR_BGR5552BGR","COLOR_BGR5552RGB","COLOR_BGR5552BGRA","COLOR_BGR5552RGBA","COLOR_BGR5552GRAY","COLOR_BGR2XYZ","COLOR_RGB2XYZ","COLOR_XYZ2BGR","COLOR_XYZ2RGB","COLOR_BGR2YCrCb","COLOR_RGB2YCrCb","COLOR_YCrCb2BGR","COLOR_YCrCb2RGB","COLOR_BGR2HSV","COLOR_RGB2HSV","COLOR_BGR2Lab","COLOR_RGB2Lab","COLOR_BayerGB2BGR","COLOR_BayerBG2RGB","COLOR_BayerGB2RGB","COLOR_BayerRG2RGB","COLOR_BGR2Luv","COLOR_RGB2Luv","COLOR_BGR2HLS","COLOR_RGB2HLS","COLOR_HSV2BGR","COLOR_HSV2RGB","COLOR_Lab2BGR","COLOR_Lab2RGB","COLOR_Luv2BGR","COLOR_Luv2RGB","COLOR_HLS2BGR","COLOR_HLS2RGB","COLOR_BayerBG2RGB_VNG","COLOR_BayerGB2RGB_VNG","COLOR_BayerRG2RGB_VNG","COLOR_BayerGR2RGB_VNG","COLOR_BGR2HSV_FULL","COLOR_RGB2HSV_FULL","COLOR_BGR2HLS_FULL","COLOR_RGB2HLS_FULL","COLOR_HSV2BGR_FULL","COLOR_HSV2RGB_FULL","COLOR_HLS2BGR_FULL","COLOR_HLS2RGB_FULL","COLOR_LBGR2Lab","COLOR_LRGB2Lab","COLOR_LBGR2Luv","COLOR_LRGB2Luv","COLOR_Lab2LBGR","COLOR_Lab2LRGB","COLOR_Luv2LBGR","COLOR_Luv2LRGB","COLOR_BGR2YUV","COLOR_RGB2YUV","COLOR_YUV2BGR","COLOR_YUV2RGB","pixelsToCvMat","pixels","matFromArray","imageDataToCvMat","imageData","matFromImageData","vectorsToCvContour","points","length","map","pt","x","y","flat","colorToCvScalar","color","Color","levels","Array","cvRotatedRectToPoints","rect","RotatedRect","cvRotatedRectToVectors","createVector","cvContourToPoints","contour","cvPointsToJS","cvPointToVector","point","cvRectVectorToArray","rectVector","array","rectVectorSize","size","ZERO_SCALAR","makeMatrix","rotation","translation","rot3x3","Mat","Rodrigues","rm","data32F","tm","applyMatrix","transformationMatrix4x4","drawMat","p5Image","matToNewImage","image","drawVectors","vectors","vector","close","numVectors","beginShape","vertex","endShape","drawRotatedRect","rotatedRect","center","translate","rotate","radians","angle","pop","drawRotatedEllipse","rotatedEllipse","ellipse","findMaxLocation","minMaxLoc","maxLoc","meanCols","colMat","row","mean","col","meanRows","rowMat","sumData","reduce","a","b","sumCols","sumRows","minCols","minVal","minRows","maxCols","maxVal","maxRows","findFirst","target","charAt","findLast","getBoundingBox","thresh","invert","THRESH_BINARY_INV","THRESH_BINARY","box","Rect","threshold","weightedAverageAngle","linesMat","angleSum","weights","start","Point","data32S","end","diff","Vector","sub","mag","weight","atan2","autorotate","threshold1","threshold2","threshMat","Canny","lines","angleResolution","PI","minLineLength","srcMat","HoughLinesP","rotationAmount","ofRadToDeg","imageToNewMat","sourceImage","imread","imageToMat","cvMat","sourceWidth","sourceHeight","getImageData","set","getCvVideoCapture","p5Capture","VideoCapture","elt","getRGBAMat","zeros","getRGBMat","getGrayscaleMat","matToImage","destinationImage","imshow","createImage","areSamesize","matA","matB","Scalar","add","invertTo","bitwise_not","lerp","lerpFromMat","lerpToMat","lerpResult","amount","addWeighted","accumulate","newMat","accumulatorMat","accumulateWeighted","normalizeTo","normalize","NORM_MINMAX","thresholdTo","thresholdValue","thresholdType","MINUS_ONE_POINT","erodeTo","iterations","erode","dilateTo","dilate","autothresholdTo","THRESH_OTSU","autothreshold","convertColor","code","targetChannels","cvtColor","convertSingleColor","p5Color","from","copyGray","copyRGB","forceOdd","Math","floor","blurTo","blur","Size","GaussianBlurTo","GaussianBlur","medianBlurTo","medianBlur","equalizeHistTo","sourceChannels","MatVector","destinationChannels","split","equalizeHist","merge","apertureSize","L2gradient","Sobel","ddepth","dx","dy","ksize","scale","delta","borderType","BORDER_DEFAULT","warpPerspective","destinationPoints","INTER_LINEAR","w","h","sourcePoints","transform","getPerspectiveTransform","unwarpPerspective","warpPerspectiveFromTranform","resizeTo","interpolation","resize","resizeToScale","xScale","yScale","dstWidth","dstHeight","resizeToDimensions","result","drawContour","cvPointsToVectors","cvFeaturesToPoints","getFeatureAsPoint","index","cvLineToJS","cvLineToVectors","getConvexHullMat","contourMat","hull","convexHull","convexHullFromMat","convexityDefectsCv","defects","convexityDefects","convexityDefectsFromVectors","minAreaRectFromVectors","minAreaRect","fitEllipseFromVectors","fitEllipse","fitLineFromVectors","line","fitLine","DIST_L2","vx","vy","lefty","round","righty","fillPoly","numPoints","setTo","FLIP_HORIZONTAL","FLIP_VERTICAL","FLIP_BOTH","flipTo","flip","rotateTo","fill","rotationMatrix","getRotationMatrix2D","warpAffine","BORDER_CONSTANT","rotate90To","transpose","rotate90","transposeTo","swap","temp","clone","trackingDistanceRect","dw","dh","sqrt","trackingDistancePoint","dist","isPoint","isRect","trackingDistance","TrackedObject","label","this","lastSeen","age","previous","old","visible","Tracker","current","currentLabels","previousLabels","newLabels","deadLabels","previousLabelMap","Map","currentLabelMap","persistence","curLabel","maximumDistance","persistance","distance","objects","concat","all","j","curDistance","pair","sort","sortByDistance","matchedObjects","matchedPrevious","allSize","k","match","newFromPrevious","initFromPreviousObject","timeStep","getLabel","newWithLabel","getNewLabel","initFromObject","getLastSeen","clear","currentSize","previousSize","has","getIndex","getAge","RectTracker","smoothingRate","smoothed","labels","labelsSize","smooth","cur","getCurrent","entries","existsCurrent","getLabelFromIndex","existsPrevious","getPrevious","previousPosition","currentPosition","PointTracker","Follower","dead","RectFollower","PointFollower","TrackerFollower","followers","curFollower","update","kill","newLabelsSize","newFollower","setup","setLabel","getDead","splice","RectTrackerFollower","PointTrackerFollower","DifferenceMode","ABSDIFF","BRIGHTER","DARKER","RunningBackground","learningRate","learningTime","useLearningTime","ignoreForeground","needToReset","differenceMode","accumulator","background","foreground","foregroundGray","frame","thresholded","empty","absdiff","subtract","thresholdMode","curLearningRate","float","pow","ObjectFinder","rescale","multiScaleFactor","minNeighbors","minSizeScale","maxSizeScale","useHistogramEqualization","cannyPrunning","findBiggestObject","gray","graySmall","classifier","CascadeClassifier","tracker","cascadeFilename","load","newFrameMat","minSize","maxSize","minSide","min","side","RectVector","detectMultiScale","cannyPruning","CASCADE_DO_CANNY_PRUNING","CASCADE_FIND_BIGGEST_OBJECT","CASCADE_DO_ROUGH_SEARCH","objectsSize","track","getSmoothed","getVelocity","getCurrentLabels","noFill","stroke","getObject","text","preset","FAST","setRescale","setMinNeighbors","setMultiScaleFactor","setMinSizeScale","setMaxSizeScale","setCannyPruning","setFindBiggestObject","ACCURATE","SENSITIVE","Flow","last","curr","hasFlow","lastMat","currentMat","calcFlow","lastSize","currSize","renderWidth","renderHeight","drawFlow","FlowPyrLK","prevPts","nextPts","windowSize","maxLevel","maxFeatures","maxCorners","blockSize","qualityLevel","minDistance","criteria","TermCriteria","TERM_CRITERIA_EPS","TERM_CRITERIA_COUNT","pyramidLevels","calcFeaturesNextFrame","pyramid","prevPyramid","err","winSize","featuresSize","features","resetFeaturesToTrack","drawX","drawY","drawWidth","drawHeight","scaleX","scaleY","prevPtsSize","LINES","prevMat","nextMat","calcFeaturesToTrack","calcOpticalFlowPyrLK","goodFeaturesToTrack","FlowFarneback","flow","pyramidScale","numLevels","numIterations","polyN","polySigma","farnebackGaussian","renderStep","constrain","gaussian","OPTFLOW_USE_INITIAL_FLOW","OPTFLOW_FARNEBACK_GAUSSIAN","calcOpticalFlowFarneback","getTotalFlowInRegion","getAverageFlowInRegion","xIndex","yIndex","position","getFlowOffset","total","regionX","regionY","regionWidth","regionHeight","rectX","rectY","rectWidth","rectHeight","flowPosition","getFlowPosition","Graph","historyLength","minValue","maxValue","history","Float32Array","sample","offset","range","strokeWeight","normalized","samePixels","a1","a2","stride","same","matAGray","matBGray","countNonZero","OFlow","step","uMotionGraph","vMotionGraph","A2","A1B2","B1","C1","C2","vv","globalX","localY","localX","newImage","oldImage","zones","winStep","uu","wMax","hMax","globalY","address","gradX","gradY","gradT","u","v","Idelta","norm","addSample","forEach","zone","draw","TrackingColorMode","TRACK_COLOR_RGB","TRACK_COLOR_HSV","TRACK_COLOR_H","TRACK_COLOR_HS","ContourFinder","hsvBuffer","autoThreshold","simplify","thresholdValueMax","useTargetColor","trackingColorMode","targetColor","minArea","maxArea","Number","POSITIVE_INFINITY","minAreaNorm","maxAreaNorm","contours","polylines","boundingRects","holes","contourFindingMode","RETR_EXTERNAL","sortBySize","resetMinArea","resetMaxArea","base","lowerb","upperb","inRange","allContours","hierarchy","simplifyMode","CHAIN_APPROX_SIMPLE","CHAIN_APPROX_NONE","findContours","needMinFilter","needMaxFilter","allIndices","allAreas","allHoles","imgArea","imgMinArea","imgMaxArea","curArea","contourArea","hole","allIndicesSize","boundingRect","findHoles","RETR_LIST","sizeSort","getBoundingRect","moments","m00","m10","m01","cvPoint","average","getCentroid","getCenter","arcLength","minEnclosingCircle","getMinAreaRect","getConvexHull","quad","infinity","minEpsilon","maxEpsilon","curEpsilon","approxPolyDP","polylinesSize","setMinArea","setMaxArea","minAreaRadius","maxAreaRadius","window"],"mappings":"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","file":"p5.cv.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","// OpenCV.js <-> p5.js setup\np5.cv = {};\np5.prototype.loadOpenCV = function () {\n  // from https://docs.opencv.org/4.4.0/utils.js\n\n  cv.onRuntimeInitialized = function () {\n    p5.cv.isReady = true;\n    if (p5.cv.onComplete) {\n      p5.cv.onComplete();\n    }\n  };\n\n  p5.cv.createFileFromUrl = function (path, url, callback) {\n    let request = new XMLHttpRequest();\n    request.open('GET', url, true);\n    request.responseType = 'arraybuffer';\n    request.onload = function (ev) {\n      if (request.readyState === 4) {\n        if (request.status === 200) {\n          let data = new Uint8Array(request.response);\n          cv.FS_createDataFile('/', path, data, true, false, false);\n          callback();\n        } else {\n          console.error('Failed to load ' + url + ' status: ' + request.status);\n        }\n      }\n    };\n    request.send();\n  };\n\n  p5.cv.loadImageToCanvas = function (url, cavansId) {\n    let canvas = document.getElementById(cavansId);\n    let ctx = canvas.getContext('2d');\n    let img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.onload = function () {\n      canvas.width = img.width;\n      canvas.height = img.height;\n      ctx.drawImage(img, 0, 0, img.width, img.height);\n    };\n    img.src = url;\n  };\n};\n\np5.prototype.registerMethod('init', p5.prototype.loadOpenCV);\n","// Utilities.h\n\np5.cv.getWidth = function (sourceMat) {\n  return sourceMat.cols;\n};\np5.cv.getHeight = function (sourceMat) {\n  return sourceMat.rows;\n};\np5.cv.getAllocated = function (sourceMat) {\n  //return p5.cv.getWidth(sourceMat) > 0 && p5.cv.getHeight(sourceMat) > 0;\n  return sourceMat.rows > 0 && sourceMat.cols > 0;\n};\np5.cv.getDepthForType = function (cvImageType) {\n  return cv.CV_MAT_DEPTH(cvImageType);\n};\np5.cv.getDepthForMat = function (sourceMat) {\n  return sourceMat.depth();\n};\n// p5.Image / p5.Graphics will use Canvas = RGBA\np5.cv.getDepthForImage = function () {\n  return cv.CV_8UC4;\n};\ncv.CV_8UC = function (channels) {\n  if (channels === 1) return cv.CV_8UC1;\n  if (channels === 2) return cv.CV_8UC2;\n  if (channels === 3) return cv.CV_8UC3;\n  if (channels === 4) return cv.CV_8UC4;\n  return cv.CV_8UC1;\n};\ncv.CV_8SC = function (channels) {\n  if (channels === 1) return cv.CV_8SC1;\n  if (channels === 2) return cv.CV_8SC2;\n  if (channels === 3) return cv.CV_8SC3;\n  if (channels === 4) return cv.CV_8SC4;\n  return cv.CV_8SC1;\n};\ncv.CV_16UC = function (channels) {\n  if (channels === 1) return cv.CV_16UC1;\n  if (channels === 2) return cv.CV_16UC2;\n  if (channels === 3) return cv.CV_16UC3;\n  if (channels === 4) return cv.CV_16UC4;\n  return cv.CV_16UC1;\n};\ncv.CV_16SC = function (channels) {\n  if (channels === 1) return cv.CV_16SC1;\n  if (channels === 2) return cv.CV_16SC2;\n  if (channels === 3) return cv.CV_16SC3;\n  if (channels === 4) return cv.CV_16SC4;\n  return cv.CV_16SC1;\n};\ncv.CV_32SC = function (channels) {\n  if (channels === 1) return cv.CV_32SC1;\n  if (channels === 2) return cv.CV_32SC2;\n  if (channels === 3) return cv.CV_32SC3;\n  if (channels === 4) return cv.CV_32SC4;\n  return cv.CV_32SC1;\n};\ncv.CV_32FC = function (channels) {\n  if (channels === 1) return cv.CV_32FC1;\n  if (channels === 2) return cv.CV_32FC2;\n  if (channels === 3) return cv.CV_32FC3;\n  if (channels === 4) return cv.CV_32FC4;\n  return cv.CV_32FC1;\n};\ncv.CV_64FC = function (channels) {\n  if (channels === 1) return cv.CV_64FC1;\n  if (channels === 2) return cv.CV_64FC2;\n  if (channels === 3) return cv.CV_64FC3;\n  if (channels === 4) return cv.CV_64FC4;\n  return cv.CV_64FC1;\n};\n\ncv.CV_CN_MAX = 512;\ncv.CV_CN_SHIFT = 3;\ncv.CV_DEPTH_MAX = 1 << cv.CV_CN_SHIFT;\n// #define CV_MAT_CN_MASK          ((CV_CN_MAX - 1) << CV_CN_SHIFT)\ncv.CV_MAT_CN_MASK = (cv.CV_CN_MAX - 1) << cv.CV_CN_SHIFT;\ncv.CV_MAT_CN = function (flags) {\n  return ((flags & cv.CV_MAT_CN_MASK) >> cv.CV_CN_SHIFT) + 1;\n};\ncv.CV_MAT_DEPTH_MASK = cv.CV_DEPTH_MAX - 1;\ncv.CV_MAT_DEPTH = function (flags) {\n  return flags & cv.CV_MAT_DEPTH_MASK;\n};\ncv.CV_MAKETYPE = function (depth, cn) {\n  return cv.CV_MAT_DEPTH(depth) + ((cn - 1) << cv.CV_CN_SHIFT);\n};\np5.cv.getCvImageType = function (channels, cvDepth = cv.CV_8U) {\n  return cv.CV_MAKETYPE(cvDepth, channels);\n};\np5.cv.getCvImageTypeForImage = function (cvDepth = CV_8U) {\n  return cv.CV_MAKETYPE(cvDepth, 4);\n};\np5.cv.getChannelsForType = function (cvImageType) {\n  return cv.CV_MAT_CN(cvImageType);\n};\n// p5.Image / p5.Graphics will use Canvas = RGBA\np5.cv.getChannelsForImage = function () {\n  return 4;\n};\np5.cv.getChannelsForMat = function (sourceMat) {\n  return sourceMat.channels();\n};\np5.cv.copyTo = function (sourceMat, destinationMat) {\n  if (sourceMat.type() === destinationMat.type()) {\n    sourceMat.copyTo(destinationMat);\n  } else {\n    let alpha = p5.cv.getMaxVal(destinationMat) / p5.cv.getMaxVal(sourceMat);\n    sourceMat.convertTo(destinationMat, destinationMat.depth(), alpha);\n  }\n};\np5.cv.copy = function (sourceMat, destinationMat) {\n  let dstDepth;\n  if (p5.cv.getAllocated(destinationMat)) {\n    dstDepth = p5.cv.getDepthForMat(destinationMat);\n  } else {\n    dstDepth = p5.cv.getDepthForMat(sourceMat);\n  }\n  p5.cv.copyTo(sourceMat, destinationMat, dstDepth);\n};\n\np5.cv.allocate = function (sourceMat, width, height, cvType) {\n  if (\n    p5.cv.getWidth(sourceMat) !== width ||\n    p5.cv.getHeight(sourceMat) !== height ||\n    p5.cv.getCvImageType(sourceMat) !== cvType\n  ) {\n    sourceMat.create(height, width, cvType);\n  }\n};\np5.cv.imitateWithType = function (mirror, original, mirrorCvImageType) {\n  let ow = p5.cv.getWidth(original),\n    oh = p5.cv.getHeight(original);\n  p5.cv.allocate(mirror, ow, oh, mirrorCvImageType);\n};\np5.cv.imitate = function (mirror, original) {\n  p5.cv.imitateWithType(mirror, original, p5.cv.getCvImageType(original));\n};\n// maximum possible values for that depth or matrix\np5.cv.getMaxValForDepth = function (cvDepth) {\n  switch (cvDepth) {\n    case cv.CV_8U:\n      return 255;\n    case cv.CV_16U:\n      return 65535;\n\n    case cv.CV_8S:\n      return 127;\n    case cv.CV_16S:\n      return 32767;\n    case cv.CV_32S:\n      return 2147483647;\n\n    case cv.CV_32F:\n      return 1.0;\n    case cv.CV_64F:\n    default:\n      return 1.0;\n  }\n};\n\np5.cv.getMaxValForMat = function (mat) {\n  return p5.cv.getMaxValForDepth(mat.depth());\n};\n\n// float getMaxVal(const cv::Mat& mat);\np5.cv.getColorConversionTypes = function () {\n  let types = [];\n  for (property in cv) {\n    if (property.indexOf('COLOR_') === 0) {\n      types.push(property);\n    }\n  }\n  return types;\n};\np5.cv.getTargetChannelsFromCode = function (conversionCode) {\n  // TODO: add the rest of the modes\n  // [\"COLOR_BGR2BGR555\",\"COLOR_BGR2BGR565\",\"COLOR_BGR2BGRA\",\"COLOR_BGR2GRAY\",\"COLOR_BGR2HLS\",\"COLOR_BGR2HLS_FULL\",\"COLOR_BGR2HSV\",\"COLOR_BGR2HSV_FULL\",\"COLOR_BGR2Lab\",\"COLOR_BGR2Luv\",\"COLOR_BGR2RGB\",\"COLOR_BGR2RGBA\",\"COLOR_BGR2XYZ\",\"COLOR_BGR2YCrCb\",\"COLOR_BGR2YUV\",\"COLOR_BGR2YUV_I420\",\"COLOR_BGR2YUV_IYUV\",\"COLOR_BGR2YUV_YV12\",\"COLOR_BGR5552BGR\",\"COLOR_BGR5552BGRA\",\"COLOR_BGR5552GRAY\",\"COLOR_BGR5552RGB\",\"COLOR_BGR5552RGBA\",\"COLOR_BGR5652BGR\",\"COLOR_BGR5652BGRA\",\"COLOR_BGR5652GRAY\",\"COLOR_BGR5652RGB\",\"COLOR_BGR5652RGBA\",\"COLOR_BGRA2BGR\",\"COLOR_BGRA2BGR555\",\"COLOR_BGRA2BGR565\",\"COLOR_BGRA2GRAY\",\"COLOR_BGRA2RGB\",\"COLOR_BGRA2RGBA\",\"COLOR_BGRA2YUV_I420\",\"COLOR_BGRA2YUV_IYUV\",\"COLOR_BGRA2YUV_YV12\",\"COLOR_BayerBG2BGR\",\"COLOR_BayerBG2BGRA\",\"COLOR_BayerBG2BGR_EA\",\"COLOR_BayerBG2BGR_VNG\",\"COLOR_BayerBG2GRAY\",\"COLOR_BayerBG2RGB\",\"COLOR_BayerBG2RGBA\",\"COLOR_BayerBG2RGB_EA\",\"COLOR_BayerBG2RGB_VNG\",\"COLOR_BayerGB2BGR\",\"COLOR_BayerGB2BGRA\",\"COLOR_BayerGB2BGR_EA\",\"COLOR_BayerGB2BGR_VNG\",\"COLOR_BayerGB2GRAY\",\"COLOR_BayerGB2RGB\",\"COLOR_BayerGB2RGBA\",\"COLOR_BayerGB2RGB_EA\",\"COLOR_BayerGB2RGB_VNG\",\"COLOR_BayerGR2BGR\",\"COLOR_BayerGR2BGRA\",\"COLOR_BayerGR2BGR_EA\",\"COLOR_BayerGR2BGR_VNG\",\"COLOR_BayerGR2GRAY\",\"COLOR_BayerGR2RGB\",\"COLOR_BayerGR2RGBA\",\"COLOR_BayerGR2RGB_EA\",\"COLOR_BayerGR2RGB_VNG\",\"COLOR_BayerRG2BGR\",\"COLOR_BayerRG2BGRA\",\"COLOR_BayerRG2BGR_EA\",\"COLOR_BayerRG2BGR_VNG\",\"COLOR_BayerRG2GRAY\",\"COLOR_BayerRG2RGB\",\"COLOR_BayerRG2RGBA\",\"COLOR_BayerRG2RGB_EA\",\"COLOR_BayerRG2RGB_VNG\",\"COLOR_GRAY2BGR\",\"COLOR_GRAY2BGR555\",\"COLOR_GRAY2BGR565\",\"COLOR_GRAY2BGRA\",\"COLOR_GRAY2RGB\",\"COLOR_GRAY2RGBA\",\"COLOR_HLS2BGR\",\"COLOR_HLS2BGR_FULL\",\"COLOR_HLS2RGB\",\"COLOR_HLS2RGB_FULL\",\"COLOR_HSV2BGR\",\"COLOR_HSV2BGR_FULL\",\"COLOR_HSV2RGB\",\"COLOR_HSV2RGB_FULL\",\"COLOR_LBGR2Lab\",\"COLOR_LBGR2Luv\",\"COLOR_LRGB2Lab\",\"COLOR_LRGB2Luv\",\"COLOR_Lab2BGR\",\"COLOR_Lab2LBGR\",\"COLOR_Lab2LRGB\",\"COLOR_Lab2RGB\",\"COLOR_Luv2BGR\",\"COLOR_Luv2LBGR\",\"COLOR_Luv2LRGB\",\"COLOR_Luv2RGB\",\"COLOR_RGB2BGR\",\"COLOR_RGB2BGR555\",\"COLOR_RGB2BGR565\",\"COLOR_RGB2BGRA\",\"COLOR_RGB2GRAY\",\"COLOR_RGB2HLS\",\"COLOR_RGB2HLS_FULL\",\"COLOR_RGB2HSV\",\"COLOR_RGB2HSV_FULL\",\"COLOR_RGB2Lab\",\"COLOR_RGB2Luv\",\"COLOR_RGB2RGBA\",\"COLOR_RGB2XYZ\",\"COLOR_RGB2YCrCb\",\"COLOR_RGB2YUV\",\"COLOR_RGB2YUV_I420\",\"COLOR_RGB2YUV_IYUV\",\"COLOR_RGB2YUV_YV12\",\"COLOR_RGBA2BGR\",\"COLOR_RGBA2BGR555\",\"COLOR_RGBA2BGR565\",\"COLOR_RGBA2BGRA\",\"COLOR_RGBA2GRAY\",\"COLOR_RGBA2RGB\",\"COLOR_RGBA2YUV_I420\",\"COLOR_RGBA2YUV_IYUV\",\"COLOR_RGBA2YUV_YV12\",\"COLOR_RGBA2mRGBA\",\"COLOR_XYZ2BGR\",\"COLOR_XYZ2RGB\",\"COLOR_YCrCb2BGR\",\"COLOR_YCrCb2RGB\",\"COLOR_YUV2BGR\",\"COLOR_YUV2BGRA_I420\",\"COLOR_YUV2BGRA_IYUV\",\"COLOR_YUV2BGRA_NV12\",\"COLOR_YUV2BGRA_NV21\",\"COLOR_YUV2BGRA_UYNV\",\"COLOR_YUV2BGRA_UYVY\",\"COLOR_YUV2BGRA_Y422\",\"COLOR_YUV2BGRA_YUNV\",\"COLOR_YUV2BGRA_YUY2\",\"COLOR_YUV2BGRA_YUYV\",\"COLOR_YUV2BGRA_YV12\",\"COLOR_YUV2BGRA_YVYU\",\"COLOR_YUV2BGR_I420\",\"COLOR_YUV2BGR_IYUV\",\"COLOR_YUV2BGR_NV12\",\"COLOR_YUV2BGR_NV21\",\"COLOR_YUV2BGR_UYNV\",\"COLOR_YUV2BGR_UYVY\",\"COLOR_YUV2BGR_Y422\",\"COLOR_YUV2BGR_YUNV\",\"COLOR_YUV2BGR_YUY2\",\"COLOR_YUV2BGR_YUYV\",\"COLOR_YUV2BGR_YV12\",\"COLOR_YUV2BGR_YVYU\",\"COLOR_YUV2GRAY_420\",\"COLOR_YUV2GRAY_I420\",\"COLOR_YUV2GRAY_IYUV\",\"COLOR_YUV2GRAY_NV12\",\"COLOR_YUV2GRAY_NV21\",\"COLOR_YUV2GRAY_UYNV\",\"COLOR_YUV2GRAY_UYVY\",\"COLOR_YUV2GRAY_Y422\",\"COLOR_YUV2GRAY_YUNV\",\"COLOR_YUV2GRAY_YUY2\",\"COLOR_YUV2GRAY_YUYV\",\"COLOR_YUV2GRAY_YV12\",\"COLOR_YUV2GRAY_YVYU\",\"COLOR_YUV2RGB\",\"COLOR_YUV2RGBA_I420\",\"COLOR_YUV2RGBA_IYUV\",\"COLOR_YUV2RGBA_NV12\",\"COLOR_YUV2RGBA_NV21\",\"COLOR_YUV2RGBA_UYNV\",\"COLOR_YUV2RGBA_UYVY\",\"COLOR_YUV2RGBA_Y422\",\"COLOR_YUV2RGBA_YUNV\",\"COLOR_YUV2RGBA_YUY2\",\"COLOR_YUV2RGBA_YUYV\",\"COLOR_YUV2RGBA_YV12\",\"COLOR_YUV2RGBA_YVYU\",\"COLOR_YUV2RGB_I420\",\"COLOR_YUV2RGB_IYUV\",\"COLOR_YUV2RGB_NV12\",\"COLOR_YUV2RGB_NV21\",\"COLOR_YUV2RGB_UYNV\",\"COLOR_YUV2RGB_UYVY\",\"COLOR_YUV2RGB_Y422\",\"COLOR_YUV2RGB_YUNV\",\"COLOR_YUV2RGB_YUY2\",\"COLOR_YUV2RGB_YUYV\",\"COLOR_YUV2RGB_YV12\",\"COLOR_YUV2RGB_YVYU\",\"COLOR_YUV420p2BGR\",\"COLOR_YUV420p2BGRA\",\"COLOR_YUV420p2GRAY\",\"COLOR_YUV420p2RGB\",\"COLOR_YUV420p2RGBA\",\"COLOR_YUV420sp2BGR\",\"COLOR_YUV420sp2BGRA\",\"COLOR_YUV420sp2GRAY\",\"COLOR_YUV420sp2RGB\",\"COLOR_YUV420sp2RGBA\",\"COLOR_mRGBA2RGBA\"]\n  if (conversionCode === cv.COLOR_RGB2RGBA) return 4;\n  if (conversionCode === cv.COLOR_RGBA2RGB) return 3;\n  if (conversionCode === cv.COLOR_RGB2BGRA) return 4;\n  if (conversionCode === cv.COLOR_RGBA2BGR) return 3;\n  if (conversionCode === cv.COLOR_BGR2RGB) return 3;\n  if (conversionCode === cv.COLOR_BGRA2RGBA) return 4;\n  if (conversionCode === cv.COLOR_BGR2GRAY) return 1;\n  if (conversionCode === cv.COLOR_RGB2GRAY) return 1;\n  if (conversionCode === cv.COLOR_GRAY2RGB) return 3;\n  if (conversionCode === cv.COLOR_GRAY2RGBA) return 4;\n  if (conversionCode === cv.COLOR_BGRA2GRAY) return 1;\n  if (conversionCode === cv.COLOR_RGBA2GRAY) return 1;\n  if (conversionCode === cv.COLOR_BGR5652BGR) return 3;\n  if (conversionCode === cv.COLOR_BGR5652RGB) return 3;\n  if (conversionCode === cv.COLOR_BGR5652BGRA) return 4;\n  if (conversionCode === cv.COLOR_BGR5652RGBA) return 4;\n  if (conversionCode === cv.COLOR_BGR5652GRAY) return 1;\n  if (conversionCode === cv.COLOR_BGR5552BGR) return 3;\n  if (conversionCode === cv.COLOR_BGR5552RGB) return 3;\n  if (conversionCode === cv.COLOR_BGR5552BGRA) return 4;\n  if (conversionCode === cv.COLOR_BGR5552RGBA) return 4;\n  if (conversionCode === cv.COLOR_BGR5552GRAY) return 1;\n  if (conversionCode === cv.COLOR_BGR2XYZ) return 3;\n  if (conversionCode === cv.COLOR_RGB2XYZ) return 3;\n  if (conversionCode === cv.COLOR_XYZ2BGR) return 3;\n  if (conversionCode === cv.COLOR_XYZ2RGB) return 3;\n  if (conversionCode === cv.COLOR_BGR2YCrCb) return 3;\n  if (conversionCode === cv.COLOR_RGB2YCrCb) return 3;\n  if (conversionCode === cv.COLOR_YCrCb2BGR) return 3;\n  if (conversionCode === cv.COLOR_YCrCb2RGB) return 3;\n  if (conversionCode === cv.COLOR_BGR2HSV) return 3;\n  if (conversionCode === cv.COLOR_RGB2HSV) return 3;\n  if (conversionCode === cv.COLOR_BGR2Lab) return 3;\n  if (conversionCode === cv.COLOR_RGB2Lab) return 3;\n  if (conversionCode === cv.COLOR_BayerGB2BGR) return 3;\n  if (conversionCode === cv.COLOR_BayerBG2RGB) return 3;\n  if (conversionCode === cv.COLOR_BayerGB2RGB) return 3;\n  if (conversionCode === cv.COLOR_BayerRG2RGB) return 3;\n  if (conversionCode === cv.COLOR_BGR2Luv) return 3;\n  if (conversionCode === cv.COLOR_RGB2Luv) return 3;\n  if (conversionCode === cv.COLOR_BGR2HLS) return 3;\n  if (conversionCode === cv.COLOR_RGB2HLS) return 3;\n  if (conversionCode === cv.COLOR_HSV2BGR) return 3;\n  if (conversionCode === cv.COLOR_HSV2RGB) return 3;\n  if (conversionCode === cv.COLOR_Lab2BGR) return 3;\n  if (conversionCode === cv.COLOR_Lab2RGB) return 3;\n  if (conversionCode === cv.COLOR_Luv2BGR) return 3;\n  if (conversionCode === cv.COLOR_Luv2RGB) return 3;\n  if (conversionCode === cv.COLOR_HLS2BGR) return 3;\n  if (conversionCode === cv.COLOR_HLS2RGB) return 3;\n  if (conversionCode === cv.COLOR_BayerBG2RGB_VNG) return 3;\n  if (conversionCode === cv.COLOR_BayerGB2RGB_VNG) return 3;\n  if (conversionCode === cv.COLOR_BayerRG2RGB_VNG) return 3;\n  if (conversionCode === cv.COLOR_BayerGR2RGB_VNG) return 3;\n  if (conversionCode === cv.COLOR_BGR2HSV_FULL) return 3;\n  if (conversionCode === cv.COLOR_RGB2HSV_FULL) return 3;\n  if (conversionCode === cv.COLOR_BGR2HLS_FULL) return 3;\n  if (conversionCode === cv.COLOR_RGB2HLS_FULL) return 3;\n  if (conversionCode === cv.COLOR_HSV2BGR_FULL) return 3;\n  if (conversionCode === cv.COLOR_HSV2RGB_FULL) return 3;\n  if (conversionCode === cv.COLOR_HLS2BGR_FULL) return 3;\n  if (conversionCode === cv.COLOR_HLS2RGB_FULL) return 3;\n  if (conversionCode === cv.COLOR_LBGR2Lab) return 3;\n  if (conversionCode === cv.COLOR_LRGB2Lab) return 3;\n  if (conversionCode === cv.COLOR_LBGR2Luv) return 3;\n  if (conversionCode === cv.COLOR_LRGB2Luv) return 3;\n  if (conversionCode === cv.COLOR_Lab2LBGR) return 4;\n  if (conversionCode === cv.COLOR_Lab2LRGB) return 4;\n  if (conversionCode === cv.COLOR_Luv2LBGR) return 4;\n  if (conversionCode === cv.COLOR_Luv2LRGB) return 4;\n  if (conversionCode === cv.COLOR_BGR2YUV) return 3;\n  if (conversionCode === cv.COLOR_RGB2YUV) return 3;\n  if (conversionCode === cv.COLOR_YUV2BGR) return 3;\n  if (conversionCode === cv.COLOR_YUV2RGB) return 3;\n  return 0;\n};\n\np5.cv.pixelsToCvMat = function (width, height, pixels) {\n  return cv.matFromArray(width, height, cv.CV_8UC4, pixels);\n};\np5.cv.imageDataToCvMat = function (imageData) {\n  return cv.matFromImageData(imageData);\n};\n// std::vector<cv::Point2f> toCv(const ofPolyline& polyline);\n// TODO: ask Golan if vectorsToCvMat is explanatory enough: this can represent a contour or a hull\np5.cv.vectorsToCvContour = function (points) {\n  // extract x,y points into value array and flatten that\n  return cv.matFromArray(\n    points.length,\n    1,\n    cv.CV_32SC2,\n    points.map((pt) => [pt.x, pt.y]).flat()\n  );\n};\np5.cv.colorToCvScalar = function (color) {\n  if (color instanceof p5.Color) {\n    return color.levels;\n  } else if (color instanceof Array) {\n    return color;\n  } else {\n    console.warn('unexpected color format', color);\n    return color;\n  }\n};\n// TODO: cv::Mat toCv(ofMesh& mesh);\n// cv::Point2f toCv(ofVec2f vec); -> not required as any object with x,y properties will do the job as an input\n// cv::Point3f toCv(ofVec3f vec); -> to be implemented later as OpenCV.js support for 3D improves\n// cv::Rect toCv(ofRectangle rect); -> not required as any object with x, y, width, height properties will do the job as an input\n// ofRectangle toOf(cv::Rect rect); -> not required as x, y, width, height properties can be accessed directly\n\n// ofPolyline toOf(cv::RotatedRect rect);\np5.cv.cvRotatedRectToPoints = function (rect) {\n  return cv.RotatedRect.points(rect);\n};\np5.cv.cvRotatedRectToVectors = function (rect) {\n  return p5.cv\n    .cvRotatedRectToPoints(rect)\n    .map((pt) => createVector(pt.x, pt.y));\n};\n// template <class T> inline ofPolyline toOf(const std::vector<cv::Point_<T> >& contour)\np5.cv.cvContourToPoints = function (contour) {\n  return p5.cv.cvPointsToJS(contour);\n};\n/* // toOf functions\n  // TODO: add p5.cv.cvMatToImageData()\n  template <class T>\n  void toOf(cv::Mat mat, ofPixels_<T>& pixels) {\n    pixels.setFromExternalPixels(mat.ptr<T>(), mat.cols, mat.rows, mat.channels());\n  }\n  template <class T>\n  void toOf(cv::Mat mat, ofImage_<T>& img) {\n    imitate(img, mat);\n    toOf(mat, img.getPixels());\n  } */\n\np5.cv.cvPointToVector = function (point) {\n  // TODO: check if _setupDone and display a useful error otherwise\n  return createVector(point.x, point.y);\n};\n\np5.cv.cvRectVectorToArray = function (rectVector, array) {\n  let rectVectorSize = rectVector.size();\n  for (let i = 0; i < rectVectorSize; i++) {\n    array.push(rectVector.get(i));\n  }\n};\n","p5.cv.ZERO_SCALAR = [0, 0, 0, 0];\n// Helpers.h\n// TODO: test ! test ! test !\n//new cv.Mat(3, 3, cv.CV_32FC1,0)\np5.cv.makeMatrix = function (rotation, translation) {\n  let rot3x3;\n  if (rotation.rows === 3 && rotation.cols === 3) {\n    rot3x3 = rotation;\n  } else {\n    //rot3x3 = new cv.Mat();\n    rot3x3 = new cv.Mat(3, 3, cv.CV_32FC1, p5.cv.ZERO_SCALAR);\n    cv.Rodrigues(rotation, rot3x3);\n  }\n  let rm = rot3x3.data32F;\n  let tm = translation.data32F;\n  // TODO: is this ok ? should it be Float32Array instead ?\n  // dafuq is this formatting, eslint?!\n  return [\n    rm[0],\n    rm[3],\n    rm[6],\n    0.0,\n    rm[1],\n    rm[4],\n    rm[7],\n    0.0,\n    rm[2],\n    rm[5],\n    rm[8],\n    0.0,\n    tm[0],\n    tm[1],\n    tm[2],\n    1.0,\n  ];\n};\n// TODO! test test test!\np5.cv.applyMatrix = function (transformationMatrix4x4) {\n  applyMatrix(...transformationMatrix4x4);\n};\n\np5.cv.drawMat = function (sourceMat, x, y, width, height) {\n  let p5Image = p5.cv.matToNewImage(sourceMat);\n  if (!width) width = sourceMat.cols;\n  if (!height) height = sourceMat.rows;\n  image(p5Image, x, y, width, height);\n  p5Image = null;\n};\n\np5.cv.drawVectors = function (vectors, close = true) {\n  let numVectors = vectors.length;\n  let vector;\n  beginShape();\n  for (let i = 0; i < numVectors; i++) {\n    vector = vectors[i];\n    vertex(vector.x, vector.y);\n  }\n  if (close) {\n    vector = vectors[0];\n    vertex(vector.x, vector.y);\n  }\n  endShape();\n};\n\np5.cv.drawRotatedRect = function (rotatedRect) {\n  let center = rotatedRect.center;\n  let size = rotatedRect.size;\n  push();\n  translate(center.x, center.y);\n  rotate(radians(rotatedRect.angle));\n  rect(-size.width * 0.5, -size.height * 0.5, size.width, size.height);\n  pop();\n};\n\np5.cv.drawRotatedEllipse = function (rotatedEllipse) {\n  let center = rotatedEllipse.center;\n  let size = rotatedEllipse.size;\n  push();\n  translate(center.x, center.y);\n  rotate(radians(rotatedEllipse.angle));\n  // p5.js uses ellipseMode(CENTER) by default\n  ellipse(0, 0, size.width, size.height);\n  pop();\n};\n\np5.cv.findMaxLocation = function (sourceMat) {\n  return cv.minMaxLoc(sourceMat).maxLoc;\n};\n// TODO: test: especially Mat type and data access\np5.cv.meanCols = function (sourceMat) {\n  let colMat = new cv.Mat(sourceMat.cols, 1, cv.CV_32FC1);\n  for (let i = 0; i < sourceMat.cols; i++) {\n    colMat.row(i).data32F[0] = cv.mean(sourceMat.col(i))[0];\n  }\n  return colMat;\n};\n\np5.cv.meanRows = function (sourceMat) {\n  let rowMat = new cv.Mat(sourceMat.rows, 1, cv.CV_32FC1);\n  for (let i = 0; i < sourceMat.cols; i++) {\n    rowMat.row(i).data32F[0] = cv.mean(sourceMat.row(i))[0];\n  }\n  return colMat;\n};\n\np5.cv.sumData = function (data) {\n  return data.reduce((a, b) => a + b);\n};\n\np5.cv.sumCols = function (sourceMat) {\n  let colMat = new cv.Mat(sourceMat.cols, 1, CV_32FC1);\n  for (let i = 0; i < sourceMat.cols; i++) {\n    // FIXME: cv.sum does not exist -> will col(i).data always work ?\n    colMat.row(i).data32F[0] = sourceMat.col(i).data.reduce((a, b) => a + b);\n  }\n  return colMat;\n};\n\np5.cv.sumRows = function (sourceMat) {\n  let rowMat = new cv.Mat(sourceMat.rows, 1, CV_32FC1);\n  for (let i = 0; i < sourceMat.rows; i++) {\n    // FIXME: cv.sum does not exist -> will data(i).data always work ?\n    rowMat.row(i).data32F[0] = sourceMat.row(i).data.reduce((a, b) => a + b);\n  }\n  return rowMat;\n};\n\np5.cv.minCols = function (sourceMat) {\n  let colMat = new cv.Mat(sourceMat.cols, 1, CV_32FC1);\n  for (let i = 0; i < sourceMat.cols; i++) {\n    colMat.row(i).data32F[0] = minMaxLoc(mat.col(i)).minVal;\n  }\n  return colMat;\n};\n\np5.cv.minRows = function (sourceMat) {\n  let rowMat = new cv.Mat(sourceMat.rows, 1, cv.CV_32FC1);\n  for (let i = 0; i < sourceMat.cols; i++) {\n    rowMat.row(i).data32F[0] = minMaxLoc(mat.row(i)).minVal;\n  }\n  return colMat;\n};\n\np5.cv.maxCols = function (sourceMat) {\n  let colMat = new cv.Mat(sourceMat.cols, 1, CV_32FC1);\n  for (let i = 0; i < sourceMat.cols; i++) {\n    colMat.row(i).data32F[0] = minMaxLoc(mat.col(i)).maxVal;\n  }\n  return colMat;\n};\n\np5.cv.maxRows = function (sourceMat) {\n  let rowMat = new cv.Mat(sourceMat.rows, 1, cv.CV_32FC1);\n  for (let i = 0; i < sourceMat.cols; i++) {\n    rowMat.row(i).data32F[0] = minMaxLoc(mat.row(i)).maxVal;\n  }\n  return colMat;\n};\n\np5.cv.findFirst = function (sourceMat, target) {\n  for (let i = 0; i < sourceMat.rows; i++) {\n    if (sourceMat.charAt(i) === target) {\n      return i;\n    }\n  }\n  return 0;\n};\n\np5.cv.findLast = function (sourceMat, target) {\n  for (let i = sourceMat.rows - 1; i >= 0; i--) {\n    if (sourceMat.charAt(i) === target) {\n      return i;\n    }\n  }\n  return 0;\n};\n\np5.cv.getBoundingBox = function (sourceMat, thresh, invert) {\n  let flags = invert ? cv.THRESH_BINARY_INV : cv.THRESH_BINARY;\n  let box = new cv.Rect();\n  let rowMat = p5.cv.meanRows(sourceMat);\n  cv.threshold(rowMat, rowMat, thresh, 255, flags);\n  box.y = p5.cv.findFirst(rowMat, 255);\n  box.height = p5.cv.findLast(rowMat, 255);\n  box.height -= box.y;\n\n  let colMat = p5.cv.meanCols(mat);\n  cv.threshold(colMat, colMat, thresh, 255, flags);\n  box.x = findFirst(colMat, 255);\n  box.width = findLast(colMat, 255);\n  box.width -= box.x;\n  return box;\n};\n\n// TODO: after October\n// // (nearest point) to the two given lines\n// template <class T>\n// cv::Point3_<T> intersectLineLine(cv::Point3_<T> lineStart1, cv::Point3_<T> lineEnd1, cv::Point3_<T> lineStart2, cv::Point3_<T> lineEnd2) {\n//     cv::Point3_<T> v1(lineEnd1 - lineStart1), v2(lineEnd2 - lineStart2);\n//     T v1v1 = v1.dot(v1), v2v2 = v2.dot(v2), v1v2 = v1.dot(v2), v2v1 = v2.dot(v1);\n//     cv::Mat_<T> lambda = (1. / (v1v1 * v2v2 - v1v2 * v1v2))\n//     * ((cv::Mat_<T>(2, 2) << v2v2, v1v2, v2v1, v1v1)\n//          * (cv::Mat_<T>(2, 1) << v1.dot(lineStart2 - lineStart1), v2.dot(lineStart1 - lineStart2)));\n//     return (1./2) * ((lineStart1 + v1 * lambda(0)) + (lineStart2 + v2 * lambda(1)));\n// }\n\n// (nearest point on a line) to the given point\n// template <class T>\n// cv::Point3_<T> intersectPointLine(cv::Point3_<T> point, cv::Point3_<T> lineStart, cv::Point3_<T> lineEnd) {\n//     cv::Point3_<T> ray = lineEnd - lineStart;\n//     T u = (point - lineStart).dot(ray) / ray.dot(ray);\n//     return lineStart + u * ray;\n// }\n\n// // (nearest point on a ray) to the given point\n// template <class T>\n// cv::Point3_<T> intersectPointRay(cv::Point3_<T> point, cv::Point3_<T> ray) {\n//     return ray * (point.dot(ray) / ray.dot(ray));\n// }\n\n// morphological thinning, also called skeletonization, strangely missing from opencv\n// here is a description of the algorithm http://homepages.inf.ed.ac.uk/rbf/HIPR2/thin.htm\n// template <class T>\n// void thin(T& img) {\n//     cv::Mat mat = toCv(img);\n//     int w = mat.cols, h = mat.rows;\n//     int ia1=-w-1,ia2=-w-0,ia3=-w+1,ib1=-0-1,ib3=-0+1,ic1=+w-1,ic2=+w-0,ic3=+w+1;\n//     unsigned char* p = mat.ptr<unsigned char>();\n//     vector<unsigned int> q;\n//     for(int y = 1; y + 1 < h; y++) {\n//         for(int x = 1; x + 1 < w; x++) {\n//             int i = y * w + x;\n//             if(p[i]) {\n//                 q.push_back(i);\n//             }\n//         }\n//     }\n//     int n = q.size();\n//     for(int i=0;i<n;i++){int j=q[i];if(!p[j+ia1]&&!p[j+ia2]&&!p[j+ia3]&&p[j+ic1]&&p[j+ic2]&&p[j+ic3]){p[j]=0;}}\n//     for(int i=0;i<n;i++){int j=q[i];if(!p[j+ia3]&&!p[j+ib3]&&!p[j+ic3]&&p[j+ia1]&&p[j+ib1]&&p[j+ic1]){p[j]=0;}}\n//     for(int i=0;i<n;i++){int j=q[i];if(!p[j+ic1]&&!p[j+ic2]&&!p[j+ic3]&&p[j+ia1]&&p[j+ia2]&&p[j+ia3]){p[j]=0;}}\n//     for(int i=0;i<n;i++){int j=q[i];if(!p[j+ia1]&&!p[j+ib1]&&!p[j+ic1]&&p[j+ia3]&&p[j+ib3]&&p[j+ic3]){p[j]=0;}}\n//     for(int i=0;i<n;i++){int j=q[i];if(!p[j+ia2]&&!p[j+ia3]&&!p[j+ib3]&&p[j+ib1]&&p[j+ic2]){p[j]=0;}}\n//     for(int i=0;i<n;i++){int j=q[i];if(!p[j+ib3]&&!p[j+ic3]&&!p[j+ic2]&&p[j+ib1]&&p[j+ia2]){p[j]=0;}}\n//     for(int i=0;i<n;i++){int j=q[i];if(!p[j+ic2]&&!p[j+ic1]&&!p[j+ib1]&&p[j+ia2]&&p[j+ib3]){p[j]=0;}}\n//     for(int i=0;i<n;i++){int j=q[i];if(!p[j+ib1]&&!p[j+ia1]&&!p[j+ia2]&&p[j+ic2]&&p[j+ib3]){p[j]=0;}}\n// }\n// additionally: https://github.com/LingDong-/skeletonization-js\n\n// given a vector of lines, this function will find the average angle\np5.cv.weightedAverageAngle = function (linesMat) {\n  let angleSum = 0;\n  let weights = 0;\n  for (let i = 0; i < linesMat.rows; i++) {\n    let start = new cv.Point(\n      linesMat.data32S[i * 4],\n      linesMat.data32S[i * 4 + 1]\n    );\n    let end = new cv.Point(\n      linesMat.data32S[i * 4 + 2],\n      linesMat.data32S[i * 4 + 3]\n    );\n    let diff = p5.Vector.sub(end, start);\n    let length = diff.mag();\n    let weight = length * length;\n    let angle = atan2(diff.y, diff.x);\n    angleSum += angle * weight;\n    weights += weight;\n  }\n  return angleSum / weights;\n};\n\n// finds the average angle of hough lines, unrotates by that amount and\n// returns the average rotation. you can supply your own thresholded image\n// for hough lines, or let it run canny detection for you.\np5.cv.autorotate = function (\n  sourceMat,\n  destinationMat,\n  threshold1 = 50,\n  threshold2 = 200\n) {\n  let threshMat = new cv.Mat();\n  cv.Canny(sourceMat, threshMat, threshold1, threshold2);\n  return autorotate(sourceMat, threshMat, destinationMat);\n};\n\np5.cv.autorotate = function (sourceMat, threshMat, destinationMat) {\n  p5.cv.imitate(destinationMat, sourceMat);\n  let lines = new cv.Mat();\n  let distanceResolution = 1.0;\n  // FIXME check if this is correct: used to be CV_PI\n  let angleResolution = PI / 180;\n  // these three values are just heuristics that have worked for me\n  let voteThreshold = 10;\n  let minLineLength = (srcMat.rows + srcMat.cols) / 8;\n  let maxLineGap = 3;\n  cv.HoughLinesP(\n    threshMat,\n    lines,\n    distanceResolution,\n    angleResolution,\n    voteThreshold,\n    minLineLength,\n    maxLineGap\n  );\n  let rotationAmount = ofRadToDeg(weightedAverageAngle(lines));\n  p5.cv.rotate(sourceMat, destinationMat, rotationAmount);\n  return rotationAmount;\n};\n\n// OCT ?\n// p5.cv.getConvexPolygon(convexHull, targetPoints) {\n//     let result = convexHull;\n\n//     const maxIterations = 16;\n//     const infinity = Number.POSITIVE_INFINITY;\n//     let minEpsilon = 0;\n//     let maxEpsilon = Number.POSITIVE_INFINITY;\n//     let curEpsilon = 16; // good initial guess\n\n//     // unbounded binary search to simplify the convex hull until it's targetPoints\n//     if(result.size() > targetPoints) {\n//         for(let i = 0; i < maxIterations; i++) {\n//             cv.approxPolyDP(Mat(convexHull), result, curEpsilon, true);\n//             if(result.size() === targetPoints) {\n//                 break;\n//             }\n//             if(result.size() > targetPoints) {\n//                 minEpsilon = curEpsilon;\n//                 if(maxEpsilon === infinity) {\n//                     curEpsilon = curEpsilon *  2;\n//                 } else {\n//                     curEpsilon = (maxEpsilon + minEpsilon) / 2;\n//                 }\n//             }\n//             if(result.size() < targetPoints) {\n//                 maxEpsilon = curEpsilon;\n//                 curEpsilon = (maxEpsilon + minEpsilon) / 2;\n//             }\n//         }\n//     }\n\n//     return result;\n// }\n\n// TODO: rename these to imageToCvMat / cvMatToImage\np5.cv.imageToNewMat = function (sourceImage) {\n  // TODO: args safety check\n  return cv.imread(sourceImage.canvas);\n};\n\np5.cv.imageToMat = function (sourceImage, cvMat) {\n  let sourceWidth = sourceImage.width;\n  let sourceHeight = sourceImage.height;\n  if (!p5.cv.getAllocated(cvMat)) {\n    p5.cv.allocate(cvMat, sourceWidth, sourceHeight, cv.CV_8UC4);\n  }\n  let data = sourceImage.canvas\n    .getContext('2d')\n    .getImageData(0, 0, sourceWidth, sourceHeight).data;\n  cvMat.data.set(data);\n};\n\np5.cv.getCvVideoCapture = function (p5Capture) {\n  return new cv.VideoCapture(p5Capture.elt);\n};\n\np5.cv.getRGBAMat = function (width, height) {\n  return cv.Mat.zeros(height, width, cv.CV_8UC4);\n};\n\np5.cv.getRGBMat = function (width, height) {\n  return cv.Mat.zeros(height, width, cv.CV_8UC3);\n};\n\np5.cv.getGrayscaleMat = function (width, height) {\n  return cv.Mat.zeros(height, width, cv.CV_8UC1);\n};\n\np5.cv.matToImage = function (sourceMat, destinationImage) {\n  // TODO: args safety check\n  cv.imshow(destinationImage.canvas, sourceMat);\n};\n\np5.cv.matToNewImage = function (sourceMat) {\n  let destinationImage = createImage(sourceMat.cols, sourceMat.rows);\n  cv.imshow(destinationImage.canvas, sourceMat);\n  return destinationImage;\n};\n\np5.cv.areSamesize = function (matA, matB) {\n  return matA.rows === matB.rows && matA.cols === matB.cols;\n};\n\ncv.Scalar.sub = function (a, b) {\n  return [a[0] - b[0], a[1] - b[1], a[2] - b[2], a[3] - b[3]];\n};\n\ncv.Scalar.add = function (a, b) {\n  return [a[0] + b[0], a[1] + b[1], a[2] + b[2], a[3] + b[3]];\n};\n\ncv.Point.sub = function (a, b) {\n  return new cv.Point(a.x - b.x, a.x - b.x);\n};\n\ncv.Point.add = function (a, b) {\n  return new cv.Point(a.x + b.x, a.x + b.x);\n};\n","// wrapThree are based on functions that operate on three Mat objects.\n// the first two are inputs, and the third is an output. for example,\n// the min() function: min(x, y, result) will calculate the per-element min\n// between x and y, and store that in result. both y and result need to\n// match x in dimensions and type. while wrapThree functions will use\n// imitate() to make sure your data is allocated correctly, you shouldn't\n// epect the function to behave properly if you haven't already allocated\n// your y argument. in general, OF images contain noise when newly allocated\n// so the result will also contain that noise.\n// #define wrapThree(name) \\\n// template <class X, class Y, class Result>\\\n// void name(X& x, Y& y, Result& result) {\\\n// imitate(y, x);\\\n// imitate(result, x);\\\n// cv::Mat xMat = toCv(x), yMat = toCv(y);\\\n// cv::Mat resultMat = toCv(result);\\\n// cv::name(xMat, yMat, resultMat);\\\n// }\n\n// wrapThree(max);\n// wrapThree(min);\n// wrapThree(multiply);\n// wrapThree(divide);\n// wrapThree(add);\n// wrapThree(subtract);\n// wrapThree(absdiff);\n// wrapThree(bitwise_and);\n// wrapThree(bitwise_or);\n// wrapThree(bitwise_xor);\n\n// Wrappers.h\np5.cv.invertTo = function (sourceMat, destinationMat) {\n  // TODO: args safety check\n  cv.bitwise_not(sourceMat, destinationMat);\n};\n// inverting non-floating point images is a just a bitwise not operation\np5.cv.invert = function (sourceMat) {\n  // TODO: args safety check\n  p5.cv.invertTo(sourceMat, sourceMat);\n};\n// also useful for taking the average/mixing two images\np5.cv.lerp = function (lerpFromMat, lerpToMat, lerpResult, amount) {\n  // TODO: args safety check (including constraining amount)\n  if (lerpToMat.cols === 0) {\n    lerpFromMat.copyTo(lerpResult);\n  } else if (lerpFromMat.cols === 0) {\n    lerpToMat.copyTo(lerpResult);\n  } else {\n    cv.addWeighted(\n      lerpFromMat,\n      amount,\n      lerpToMat,\n      1.0 - amount,\n      0.0,\n      lerpResult\n    );\n  }\n};\np5.cv.accumulate = function (newMat, accumulatorMat) {\n  // FIXME: handle type differences, currently assumes sourceMat and destinationMat are the same type\n  cv.add(newMat, accumulatorMat, accumulatorMat);\n};\np5.cv.accumulateWeighted = function (\n  newMat,\n  accumulatorMat,\n  alpha,\n  mask = null\n) {\n  // imageA = alpha*imageA + (1-alpha)*imageB;\n  p5.cv.lerp(accumulatorMat, newMat, accumulatorMat, alpha);\n};\n// normalize the min/max to [0, max for this type] out of place\np5.cv.normalizeTo = function (sourceMat, destinationMat) {\n  // TODO: args safety check\n  cv.normalize(\n    sourceMat,\n    destinationMat,\n    0,\n    p5.cv.getMaxValForMat(destinationMat),\n    cv.NORM_MINMAX\n  );\n};\n// TODO: test more\n// normalize the min/max to [0, max for this type] in place\np5.cv.normalize = function (sourceMat) {\n  // TODO: args safety check\n  p5.cv.normalizeTo(sourceMat, sourceMat);\n};\n// TODO: test if invert does anything\n// threshold out of place\np5.cv.thresholdTo = function (\n  sourceMat,\n  destinationMat,\n  thresholdValue,\n  invert = false\n) {\n  p5.cv.imitate(destinationMat, sourceMat);\n  let thresholdType = invert ? cv.THRESH_BINARY_INV : cv.THRESH_BINARY;\n  let maxVal = p5.cv.getMaxValForMat(destinationMat);\n  // cv.threshold(sourceMat, destinationMat, thresholdValue, maxVal, thresholdType);\n  cv.threshold(\n    sourceMat,\n    destinationMat,\n    thresholdValue,\n    maxVal,\n    thresholdType\n  );\n};\n// threshold in place\np5.cv.threshold = function (sourceMat, thresholdValue, invert = false) {\n  p5.cv.thresholdTo(sourceMat, sourceMat, thresholdValue, invert);\n};\n// cache reusable point\np5.cv.MINUS_ONE_POINT = new cv.Point(-1, -1);\n// FIXME: load cv nicely and cache this\n// p5.cv.DEFAULT_KERNEL_MAT = new cv.Mat();\n// erode out of place\np5.cv.erodeTo = function (sourceMat, destinationMat, iterations = 1) {\n  p5.cv.imitate(destinationMat, sourceMat);\n  cv.erode(\n    sourceMat,\n    destinationMat,\n    new cv.Mat(),\n    p5.cv.MINUS_ONE_POINT,\n    iterations\n  );\n};\n// erode in place\np5.cv.erode = function (sourceMat, iterations = 1) {\n  p5.cv.erodeTo(sourceMat, sourceMat, iterations);\n};\n\n// dilate out of place\np5.cv.dilateTo = function (sourceMat, destinationMat, iterations = 1) {\n  p5.cv.imitate(destinationMat, sourceMat);\n  cv.dilate(\n    sourceMat,\n    destinationMat,\n    new cv.Mat(),\n    p5.cv.MINUS_ONE_POINT,\n    iterations\n  );\n};\n\n// dilate in place\np5.cv.dilate = function (sourceMat, iterations = 1) {\n  p5.cv.dilateTo(sourceMat, sourceMat, iterations);\n};\n\n// automatic threshold (grayscale 8-bit only) out of place\np5.cv.autothresholdTo = function (sourceMat, destinationMat, invert = false) {\n  p5.cv.imitate(destinationMat, sourceMat);\n  let flags =\n    cv.THRESH_OTSU | (invert ? cv.THRESH_BINARY_INV : cv.THRESH_BINARY);\n  cv.threshold(sourceMat, destinationMat, 0, 255, flags);\n};\n\n// automatic threshold (grayscale 8-bit only) in place\np5.cv.autothreshold = function (sourceMat, invert = false) {\n  p5.cv.autothresholdTo(sourceMat, sourceMat, invert);\n};\n\n// CV_RGB2GRAY, CV_HSV2RGB, etc. with [RGB, BGR, GRAY, HSV, HLS, XYZ, YCrCb, Lab, Luv]\n// you can convert whole images...\np5.cv.convertColor = function (sourceMat, destinationMat, code) {\n  // cvtColor allocates Mat for you, but we need this to handle ofImage etc.\n  let targetChannels = p5.cv.getTargetChannelsFromCode(code);\n  p5.cv.imitate(\n    destinationMat,\n    sourceMat,\n    p5.cv.getCvImageType(targetChannels, p5.cv.getDepthForMat(sourceMat))\n  );\n  cv.cvtColor(sourceMat, destinationMat, code);\n};\n// ...or single colors.\n// TODO: ask Golan about a decent way to tackle this.\n// return color (but have it clamped to 0-255) ?\n// test under different colorMode options\n// !!!!note it converts RGB, not RGB\np5.cv.convertSingleColor = function (p5Color, code) {\n  let mat = cv.Mat.zeros(1, 1, cv.CV_8UC3);\n  // TODO: check if array.length < 4, if fill in the blanks\n  let levels;\n  if (p5Color instanceof p5.Color) {\n    levels = p5Color.levels;\n  } else if (p5Color instanceof Array) {\n    levels = p5Color;\n  } else {\n    console.warn('unsupported format');\n    return mat.data;\n  }\n\n  mat.data[0] = levels[0];\n  mat.data[1] = levels[1];\n  mat.data[2] = levels[2];\n\n  cv.cvtColor(mat, mat, code);\n  let data = Array.from(mat.data);\n  // add alpha back in\n  data.push(levels[4]);\n  return data;\n};\n\n// a common cv task is to convert something to grayscale. this function will\n// do that quickly for RGBA, RGB, and 1-channel images.\np5.cv.copyGray = function (sourceMat, destinationMat) {\n  let channels = p5.cv.getChannelsForMat(sourceMat);\n  if (channels === 4) {\n    p5.cv.convertColor(sourceMat, destinationMat, cv.COLOR_RGBA2GRAY);\n  } else if (channels === 3) {\n    p5.cv.convertColor(sourceMat, destinationMat, cv.COLOR_RGB2GRAY);\n  } else if (channels === 1) {\n    sourceMat.copyTo(destinationMat);\n  }\n};\n\np5.cv.copyRGB = function (sourceMat, destinationMat) {\n  let channels = p5.cv.getChannelsForMat(sourceMat);\n  if (channels === 4) {\n    p5.cv.convertColor(sourceMat, destinationMat, cv.COLOR_RGBA2RGB);\n  } else if (channels === 3) {\n    sourceMat.copyTo(destinationMat);\n  } else if (channels === 1) {\n    p5.cv.convertColor(sourceMat, destinationMat, cv.COLOR_GRAY2RGB);\n  }\n};\n\np5.cv.forceOdd = function (x) {\n  return Math.floor(x / 2) * 2 + 1;\n};\n\n// box blur\np5.cv.blurTo = function (sourceMat, destinationMat, size) {\n  p5.cv.imitate(destinationMat, sourceMat);\n  size = p5.cv.forceOdd(size);\n  cv.blur(sourceMat, destinationMat, new cv.Size(size, size));\n};\n// in-place box blur\np5.cv.blur = function (sourceMat, size) {\n  p5.cv.blurTo(sourceMat, sourceMat, size);\n};\n\n// Gaussian blur\np5.cv.GaussianBlurTo = function (sourceMat, destinationMat, size) {\n  p5.cv.imitate(destinationMat, sourceMat);\n  size = p5.cv.forceOdd(size);\n  cv.GaussianBlur(sourceMat, destinationMat, new cv.Size(size, size), 0, 0);\n};\n\n// in-place Gaussian blur\np5.cv.GaussianBlur = function (sourceMat, size) {\n  p5.cv.GaussianBlurTo(sourceMat, sourceMat, size);\n};\n\n// Median blur\np5.cv.medianBlurTo = function (sourceMat, destinationMat, size) {\n  p5.cv.imitate(destinationMat, sourceMat);\n  size = p5.cv.forceOdd(size);\n  cv.medianBlur(sourceMat, destinationMat, size);\n};\n\n// in-place Median blur\np5.cv.medianBlur = function (sourceMat, size) {\n  p5.cv.medianBlurTo(sourceMat, sourceMat, size);\n};\n\n// histogram equalization, adds support for color images\np5.cv.equalizeHistTo = function (sourceMat, destinationMat) {\n  p5.cv.imitate(destinationMat, sourceMat);\n  if (sourceMat.channels() > 1) {\n    let sourceChannels = new cv.MatVector();\n    let destinationChannels = new cv.MatVector();\n    split(sourceMat, sourceChannels);\n    split(destinationMat, destinationChannels);\n    for (let i = 0; i < sourceChannels.size(); i++) {\n      cv.equalizeHist(sourceChannels.get(i), destinationChannels.get(i));\n    }\n    cv.merge(destinationChannels, destinationChannels);\n  } else {\n    cv.equalizeHist(sourceMat, destinationMat);\n  }\n};\n\np5.cv.equalizeHist = function (sourceMat) {\n  p5.cv.equalizeHistTo(sourceMat, sourceMat);\n};\n\n// Canny edge detection assumes your input and output are grayscale 8-bit\n// example thresholds might be 0,30 or 50,200\n// TODO: ask Golan if there's a reason to add an in-place version\np5.cv.Canny = function (\n  sourceMat,\n  destinationMat,\n  threshold1,\n  threshold2,\n  apertureSize = 3,\n  L2gradient = false\n) {\n  p5.cv.imitate(destinationMat, sourceMat, cv.CV_8UC1);\n  cv.Canny(\n    sourceMat,\n    destinationMat,\n    threshold1,\n    threshold2,\n    apertureSize,\n    L2gradient\n  );\n};\n\n// Sobel edge detection\np5.cv.Sobel = function (\n  sourceMat,\n  destinationMat,\n  ddepth = -1,\n  dx = 1,\n  dy = 1,\n  ksize = 3,\n  scale = 1,\n  delta = 0,\n  borderType = cv.BORDER_DEFAULT\n) {\n  p5.cv.imitate(destinationMat, sourceMat, cv.CV_8UC1);\n  cv.Sobel(\n    sourceMat,\n    destinationMat,\n    ddepth,\n    dx,\n    dy,\n    ksize,\n    scale,\n    delta,\n    borderType\n  );\n};\n// CLD missing at the moment\n\n// TODO: test ! test ! test!\n// dst does not imitate src\np5.cv.warpPerspective = function (\n  sourceMat,\n  destinationMat,\n  destinationPoints,\n  flags = cv.INTER_LINEAR\n) {\n  if (destinationPoints.type() !== cv.CV_32FC2) {\n    destinationPoints.convertTo(destinationPoints, cv.CV_32FC2);\n  }\n  // TODO validate args !!!\n  let w = sourceMat.cols;\n  let h = sourceMat.rows;\n  let sourcePoints = cv.matFromArray(4, 1, cv.CV_32FC2, [\n    0,\n    0,\n    w,\n    0,\n    w,\n    h,\n    0,\n    h,\n  ]);\n  if (destinationPoints instanceof Array) {\n    // FIXME: maybe convert this from [x1,y1,x2,y2,x3,y3...] to [{x:0,y:0}...] or [p5.Vector(),...]\n    destinationPoints = cv.matFromArray(4, 1, cv.CV_32FC2, destinationPoints);\n  }\n  let transform = cv.getPerspectiveTransform(sourcePoints, destinationPoints);\n  cv.warpPerspective(\n    sourceMat,\n    destinationMat,\n    transform,\n    destinationMat.size(),\n    flags\n  );\n};\n// dst does not imitate src\np5.cv.unwarpPerspective = function (\n  sourceMat,\n  destinationMat,\n  sourcePoints,\n  flags = cv.INTER_LINEAR\n) {\n  if (sourcePoints.type() !== cv.CV_32FC2) {\n    sourcePoints.convertTo(sourcePoints, cv.CV_32FC2);\n  }\n  let w = destinationMat.cols;\n  let h = destinationMat.rows;\n  let destinationPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [\n    0,\n    0,\n    w,\n    0,\n    w,\n    h,\n    0,\n    h,\n  ]);\n\n  let transform = cv.getPerspectiveTransform(sourcePoints, destinationPoints);\n  cv.warpPerspective(\n    sourceMat,\n    destinationMat,\n    transform,\n    destinationMat.size(),\n    flags\n  );\n};\n\n// dst does not imitate src\np5.cv.warpPerspectiveFromTranform = function (\n  sourceMat,\n  destinationMat,\n  transform,\n  flags = cv.INTER_LINEAR\n) {\n  cv.warpPerspective(\n    sourceMat,\n    destinationMat,\n    transform,\n    destinationMat.size(),\n    flags\n  );\n};\n\n// also: INTER_NEAREST, INTER_AREA, INTER_CUBIC, INTER_LANCZOS4\np5.cv.resizeTo = function (\n  sourceMat,\n  destinationMat,\n  interpolation = cv.INTER_LINEAR\n) {\n  // TODO: validation args (especially destination Mat (e.g. width !=== 0, height !=== 0))\n  cv.resize(\n    sourceMat,\n    destinationMat,\n    destinationMat.size(),\n    0,\n    0,\n    interpolation\n  );\n};\n\n// also: INTER_NEAREST, INTER_AREA, INTER_CUBIC, INTER_LANCZOS4\np5.cv.resizeToScale = function (\n  sourceMat,\n  destinationMat,\n  xScale,\n  yScale,\n  interpolation = cv.INTER_LINEAR\n) {\n  let dstWidth = Math.floor(p5.cv.getWidth(sourceMat) * xScale),\n    dstHeight = Math.floor(p5.cv.getHeight(sourceMat) * yScale);\n  if (\n    p5.cv.getWidth(destinationMat) !== dstWidth ||\n    p5.cv.getHeight(destinationMat) !== dstHeight\n  ) {\n    p5.cv.allocate(\n      destinationMat,\n      dstWidth,\n      dstHeight,\n      p5.cv.getCvImageType(sourceMat)\n    );\n  }\n  cv.resize(\n    sourceMat,\n    destinationMat,\n    { width: dstWidth, height: dstHeight },\n    interpolation\n  );\n};\n\np5.cv.resizeToDimensions = function (\n  sourceMat,\n  destinationMat,\n  dstWidth,\n  dstHeight,\n  interpolation = cv.INTER_LINEAR\n) {\n  if (\n    p5.cv.getWidth(destinationMat) !== dstWidth ||\n    p5.cv.getHeight(destinationMat) !== dstHeight\n  ) {\n    p5.cv.allocate(\n      destinationMat,\n      dstWidth,\n      dstHeight,\n      p5.cv.getCvImageType(sourceMat)\n    );\n  }\n  cv.resize(\n    sourceMat,\n    destinationMat,\n    { width: dstWidth, height: dstHeight },\n    interpolation\n  );\n};\n\np5.cv.cvPointsToJS = function (mat) {\n  let result = [];\n  for (let i = 0; i < mat.rows; i++) {\n    result.push({ x: mat.data32S[i * 2], y: mat.data32S[i * 2 + 1] });\n  }\n  return result;\n};\n\np5.cv.drawContour = function (mat, close = true) {\n  beginShape();\n  for (let i = 0; i < mat.rows; i++) {\n    vertex(mat.data32S[i * 2], mat.data32S[i * 2 + 1]);\n  }\n  if (close) {\n    vertex(mat.data32S[0], mat.data32S[1]);\n  }\n  endShape();\n};\n\np5.cv.cvPointsToVectors = function (mat) {\n  let result = [];\n  for (let i = 0; i < mat.rows; i++) {\n    result.push(createVector(mat.data32S[i * 2], mat.data32S[i * 2 + 1]));\n  }\n  return result;\n};\n\np5.cv.cvFeaturesToPoints = function (mat) {\n  let result = [];\n  for (let i = 0; i < mat.rows; i++) {\n    result.push({ x: mat.data32F[i * 2], y: mat.data32F[i * 2 + 1] });\n  }\n  return result;\n};\n\np5.cv.getFeatureAsPoint = function (mat, index) {\n  return { x: mat.data32F[index * 2], y: mat.data32F[index * 2 + 1] };\n};\n\np5.cv.cvLineToJS = function (mat) {\n  let result = [];\n  for (let i = 0; i < mat.rows; i++) {\n    result.push({ x: mat.data32F[i * 2], y: mat.data32F[i * 2 + 1] });\n  }\n  return result;\n};\n\np5.cv.cvLineToVectors = function (mat) {\n  let result = [];\n  for (let i = 0; i < mat.rows; i++) {\n    result.push(createVector(mat.data32F[i * 2], mat.data32F[i * 2 + 1]));\n  }\n  return result;\n};\n\np5.cv.getConvexHullMat = function (contourMat) {\n  let hull = new cv.Mat();\n  cv.convexHull(contourMat, hull);\n  return hull;\n};\n\np5.cv.convexHullFromMat = function (contourMat) {\n  return p5.cv.cvPointsToJS(p5.cv.getConvexHullMat(contourMat));\n};\n\np5.cv.convexHull = function (vectors) {\n  let contour = p5.cv.vectorsToCvContour(vectors);\n  return p5.cv.convexHullFromMat(contour);\n};\n\np5.cv.convexityDefectsCv = function (contourMat) {\n  let hull = new cv.Mat();\n  let defects = new cv.Mat();\n  cv.convexHull(contourMat, hull, false, false);\n  cv.convexityDefects(contourMat, hull, defects);\n  return defects;\n};\n\np5.cv.convexityDefectsFromVectors = function (vectors) {\n  return p5.cv.cvPointsToVectors(\n    p5.cv.convexityDefectsCv(p5.cv.vectorsToCvContour(vectors))\n  );\n};\n\np5.cv.minAreaRectFromVectors = function (vectors) {\n  return cv.minAreaRect(p5.cv.vectorsToCvContour(vectors));\n};\n\np5.cv.fitEllipseFromVectors = function (vectors) {\n  return cv.fitEllipse(p5.cv.vectorsToCvContour(vectors));\n};\n// TODO: test more, fix as needed\np5.cv.fitLineFromVectors = function (vectors, height) {\n  let line = new cv.Mat();\n  cv.fitLine(\n    p5.cv.vectorsToCvContour(vectors),\n    line,\n    cv.DIST_L2,\n    0,\n    0.01,\n    0.01\n  );\n  // return p5.cv.cvLineToVectors(line);\n  // if(frameCount === 75){\n  //   console.log(line);\n  // }\n\n  let vx = line.data32F[0];\n  let vy = line.data32F[1];\n  let x = line.data32F[2];\n  let y = line.data32F[3];\n  let lefty = Math.round((-x * vy) / vx + y);\n  let righty = Math.round(((height - x) * vy) / vx + y);\n  let point1 = createVector(height - 1, righty);\n  let point2 = createVector(0, lefty);\n  return [point1, point2];\n};\n\n// TODO: test\n// kind of obscure function, draws filled polygons on the CPU\np5.cv.fillPoly = function (points, destinationMat) {\n  let numPoints = [points.length];\n  destinationMat.setTo(p5.cv.ZERO_SCALAR);\n  cv.fillPoly(destinationMat, points, numPoints, 1, [255, 255, 255, 255]);\n};\n\np5.cv.FLIP_HORIZONTAL = 1;\np5.cv.FLIP_VERTICAL = 0;\np5.cv.FLIP_BOTH = -1;\n\np5.cv.flipTo = function (sourceMat, destinationMat, code) {\n  p5.cv.imitate(destinationMat, sourceMat);\n  cv.flip(sourceMat, destinationMat, code);\n};\n\np5.cv.flip = function (sourceMat, code) {\n  p5.cv.flipTo(sourceMat, sourceMat, code);\n};\n\n// if you're doing the same rotation multiple times, it's better to precompute\n// the displacement and use remap.\np5.cv.rotateTo = function (\n  sourceMat,\n  destinationMat,\n  angle,\n  fill = [0, 0, 0, 255],\n  interpolation = cv.INTER_LINEAR\n) {\n  p5.cv.imitate(destinationMat, sourceMat);\n  let center = new cv.Point(\n    Math.floor(sourceMat.cols * 0.5),\n    Math.floor(sourceMat.rows * 0.5)\n  );\n  let rotationMatrix = cv.getRotationMatrix2D(center, angle, 1);\n  cv.warpAffine(\n    sourceMat,\n    destinationMat,\n    rotationMatrix,\n    sourceMat.size(),\n    interpolation,\n    cv.BORDER_CONSTANT,\n    fill\n  );\n};\n\np5.cv.rotate = function (\n  sourceMat,\n  angle,\n  fill = [0, 0, 0, 255],\n  interpolation = cv.INTER_LINEAR\n) {\n  p5.cv.rotateTo(sourceMat, sourceMat, angle, fill, interpolation);\n};\n\n// efficient version of rotate that only operates on 0, 90, 180, 270 degrees\n// the output is allocated to contain all pixels of the input.\n// TODO: check if allocate calls are actually required!!!\np5.cv.rotate90To = function (sourceMat, destinationMat, angle) {\n  if (angle === 0) {\n    sourceMat.copyTo(destinationMat);\n  } else if (angle === 90) {\n    // p5.cv.allocate(destinationMat, sourceMat.rows, sourceMat.cols, sourceMat.type());\n    cv.transpose(sourceMat, destinationMat);\n    cv.flip(sourceMat, destinationMat, p5.cv.FLIP_HORIZONTAL);\n  } else if (angle === 180) {\n    p5.cv.imitate(destinationMat, sourceMat);\n    cv.flip(sourceMat, destinationMat, p5.cv.FLIP_BOTH);\n  } else if (angle === 270) {\n    // p5.cv.allocate(destinationMat, sourceMat.rows, sourceMat.cols, sourceMat.type());\n    cv.transpose(sourceMat, destinationMat);\n    // cv.flip(sourceMat, destinationMat, p5.cv.FLIP_VERTICAL);\n  }\n};\n\np5.cv.rotate90 = function (sourceMat, angle) {\n  p5.cv.rotate90To(sourceMat, sourceMat, angle);\n};\n\np5.cv.transposeTo = function (sourceMat, destinationMat) {\n  //p5.cv.allocate(destinationMat, sourceMat.rows, sourceMat.cols, sourceMat.type());\n  cv.transpose(sourceMat, destinationMat);\n};\n\np5.cv.transpose = function (sourceMat) {\n  p5.cv.transposeTo(sourceMat, sourceMat);\n};\n\np5.cv.swap = function (a, b) {\n  let temp = a.clone();\n  b.copyTo(a);\n  temp.copyTo(b);\n  temp.delete();\n};\n","p5.cv.trackingDistanceRect = function (a, b) {\n  let dx = a.x + a.width * 0.5 - (b.x + b.width * 0.5);\n  let dy = a.y + a.height * 0.5 - (b.y + b.height * 0.5);\n  let dw = a.width - b.width;\n  let dh = a.height - b.height;\n  let pd = Math.sqrt(dx * dx + dy * dy);\n  let sd = Math.sqrt(dw * dw + dh * dh);\n  return pd + sd;\n};\n\np5.cv.trackingDistancePoint = function (a, b) {\n  return dist(a.x, a.y, b.x, b.y);\n};\n\np5.cv.isPoint = function (pt) {\n  return 'x' in pt && 'y' in pt && !('width' in pt);\n};\n\np5.cv.isRect = function (pt) {\n  return 'x' in pt && 'y' in pt && 'width' in pt && 'height' in pt;\n};\n\np5.cv.trackingDistance = function (a, b) {\n  if (p5.cv.isPoint(a) && p5.cv.isPoint(b)) {\n    return p5.cv.trackingDistancePoint(a, b);\n  }\n  if (p5.cv.isRect(a) && p5.cv.isRect(b)) {\n    return p5.cv.trackingDistanceRect(a, b);\n  }\n  console.warn(\n    'invalid input: currently supporting only points(e.g. {x:0,y:0}) and rectangles({x:0,y:0,width:10,height:10})'\n  );\n  return -1;\n};\n\nclass TrackedObject {\n  initFromObject(object, label, index) {\n    this.lastSeen = 0;\n    this.label = label;\n    this.age = 0;\n    this.index = index;\n    this.object = object;\n    return this;\n  }\n\n  initFromPreviousObject(object, previous, index) {\n    this.lastSeen = 0;\n    this.label = previous.label;\n    this.age = previous.age;\n    this.index = index;\n    this.object = object;\n    return this;\n  }\n\n  copyFrom(old) {\n    this.lastSeen = old.lastSeen;\n    this.label = old.label;\n    this.age = old.age;\n    this.index = -1;\n    this.object = old.object;\n    return this;\n  }\n\n  timeStep(visible) {\n    this.age++;\n    if (!visible) {\n      this.lastSeen++;\n    }\n  }\n\n  getLastSeen() {\n    return this.lastSeen;\n  }\n\n  getAge() {\n    return this.age;\n  }\n\n  getLabel() {\n    return this.label;\n  }\n\n  getIndex() {\n    return this.index;\n  }\n}\n\nclass Tracker {\n  constructor() {\n    this.previous = [];\n    this.current = [];\n    this.currentLabels = [];\n    this.previousLabels = [];\n    this.newLabels = [];\n    this.deadLabels = [];\n\n    this.previousLabelMap = new Map();\n    this.currentLabelMap = new Map();\n\n    this.persistence = 15;\n    this.curLabel = 0;\n\n    this.maximumDistance = 64;\n  }\n\n  getNewLabel() {\n    return this.curLabel++;\n  }\n\n  setPersistence(persistence) {\n    this.persistance = persistence;\n  }\n\n  setMaximumDistance(maximumDistance) {\n    this.maximumDistance = maximumDistance;\n  }\n\n  sortByDistance(a, b) {\n    if (a.distance > b.distance) return 1;\n    if (a.distance < b.distance) return -1;\n    return 0;\n  }\n\n  track(objects) {\n    // TODO: check if this is mean to update reference or copy values\n    // this.previous = this.current;\n    this.previous = [].concat(this.current);\n\n    let n = objects.length;\n    let m = this.previous.length;\n\n    // matchPair = {index1:index2};\n    // matchDistancePair = {pair: matchPair, distance: dist}\n    let all = [];\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < m; j++) {\n        let curDistance = p5.cv.trackingDistance(\n          objects[i],\n          this.previous[j].object\n        );\n        if (curDistance < this.maximumDistance) {\n          all.push({ pair: [i, j], distance: curDistance });\n        }\n      }\n    }\n\n    all.sort(this.sortByDistance);\n\n    // previousLabels = currentLabels;\n    this.previousLabels = [].concat(this.currentLabels);\n    this.currentLabels = new Array(n);\n    this.current.length = 0;\n\n    let matchedObjects = new Array(n).fill(false);\n    let matchedPrevious = new Array(m).fill(false);\n    // walk through matches in order\n    let allSize = all.length;\n    for (let k = 0; k < allSize; k++) {\n      let match = all[k].pair;\n      let i = match[0];\n      let j = match[1];\n      // only use match if both objects are unmatched, lastSeen is set to 0\n      if (!matchedObjects[i] && !matchedPrevious[j]) {\n        matchedObjects[i] = true;\n        matchedPrevious[j] = true;\n        let index = this.current.length;\n        let newFromPrevious = new TrackedObject().initFromPreviousObject(\n          objects[i],\n          this.previous[j],\n          index\n        );\n        this.current.push(newFromPrevious);\n        newFromPrevious.timeStep(true);\n        this.currentLabels[i] = newFromPrevious.getLabel();\n      }\n    }\n\n    // create new labels for new unmatched objects, lastSeen is set to 0\n    this.newLabels.length = 0;\n    for (let i = 0; i < n; i++) {\n      if (!matchedObjects[i]) {\n        let curLabel = this.getNewLabel();\n        let index = this.current.length;\n        let newWithLabel = new TrackedObject().initFromObject(\n          objects[i],\n          curLabel,\n          index\n        );\n        this.current.push(newWithLabel);\n        newWithLabel.timeStep(true);\n        this.currentLabels[i] = curLabel;\n        this.newLabels.push(curLabel);\n      }\n    }\n\n    // copy old unmatched objects if young enough, lastSeen is increased\n    this.deadLabels.length = 0;\n    for (let j = 0; j < m; j++) {\n      if (!matchedPrevious[j]) {\n        if (this.previous[j].getLastSeen() < this.persistence) {\n          this.current.push(this.previous[j]);\n          this.current[this.current.length - 1].timeStep(false);\n        }\n        this.deadLabels.push(this.previous[j].getLabel());\n      }\n    }\n\n    // build label maps\n    this.currentLabelMap.clear();\n    let currentSize = this.current.length;\n    for (let i = 0; i < currentSize; i++) {\n      let label = this.current[i].getLabel();\n      this.currentLabelMap.set(label, this.current[i]);\n    }\n    this.previousLabelMap.clear();\n    let previousSize = this.previous.length;\n    for (let i = 0; i < previousSize; i++) {\n      let label = this.previous[i].getLabel();\n      this.previousLabelMap.set(label, this.previous[i]);\n    }\n\n    return this.currentLabels;\n  }\n\n  getCurrentLabels() {\n    return this.currentLabels;\n  }\n\n  getPreviousLabels() {\n    return this.previousLabels;\n  }\n\n  getNewLabels() {\n    return this.newLabels;\n  }\n\n  getDeadLabels() {\n    return this.deadLabels;\n  }\n  getLabelFromIndex(i) {\n    return this.currentLabels[i];\n  }\n  // TODO: test with invalid label\n  getIndexFromLabel(label) {\n    if (this.currentLabelMap.has(label)) {\n      return this.currentLabelMap.get(label).getIndex();\n    }\n    console.warn('label', label, 'not found');\n  }\n  getPrevious(label) {\n    // return previousLabelMap.find(label)->second->object;\n    if (this.previousLabelMap.has(label)) {\n      return this.previousLabelMap.get(label).object;\n    }\n    console.warn('label', label, 'not found');\n  }\n  getCurrent(label) {\n    if (this.currentLabelMap.has(label)) {\n      return this.currentLabelMap.get(label).object;\n    }\n    console.warn('label', label, 'not found');\n  }\n  existsCurrent(label) {\n    return this.currentLabelMap.has(label);\n  }\n  existsPrevious(label) {\n    return this.previousLabelMap.has(label);\n  }\n  getAge(label) {\n    if (this.currentLabelMap.has(label)) {\n      return this.currentLabelMap.get(label).getAge();\n    }\n    console.warn('label', label, 'not found');\n  }\n  getLastSeen(label) {\n    if (this.currentLabelMap.has(label)) {\n      return this.currentLabelMap.get(label).getLastSeen();\n    }\n    console.warn('label', label, 'not found');\n  }\n}\n\nclass RectTracker extends Tracker {\n  constructor() {\n    super();\n    this.smoothingRate = 0.5;\n    // std::map<unsigned int, cv::Rect> smoothed;\n    this.smoothed = new Map();\n  }\n\n  setSmoothingRate(smoothingRate) {\n    this.smoothingRate = smoothingRate;\n  }\n  getSmoothingRate() {\n    return this.smoothingRate;\n  }\n\n  track(objects) {\n    let labels = super.track(objects);\n    // add new objects, update old objects\n    let labelsSize = labels.length;\n    for (let i = 0; i < labelsSize; i++) {\n      let label = labels[i];\n      let cur = this.getCurrent(label);\n      if (this.smoothed.has(label)) {\n        let smooth = this.smoothed.get(label);\n        smooth.x = lerp(smooth.x, cur.x, smoothingRate);\n        smooth.y = lerp(smooth.y, cur.y, smoothingRate);\n        smooth.width = lerp(smooth.width, cur.width, smoothingRate);\n        smooth.height = lerp(smooth.height, cur.height, smoothingRate);\n      } else {\n        this.smoothed[label] = cur;\n      }\n    }\n    // TODO: check if this is legit both global and instance p5.js modes\n    for (const [label, trackedRect] of this.smoothed.entries()) {\n      if (!this.existsCurrent(label)) {\n        this.smoothed.delete(label);\n        trackedRect; //eslint :/\n      }\n    }\n\n    return labels;\n  }\n\n  getSmoothed(label) {\n    if (this.smoothed.has(label)) {\n      return this.smoothed.get(label);\n    }\n    console.warn('label', label, 'not found');\n  }\n\n  getVelocity(i) {\n    let label = this.getLabelFromIndex(i);\n    // TODO: validate / handle i not found\n    if (this.existsPrevious(label)) {\n      let previous = this.getPrevious(label);\n      let current = this.getCurrent(label);\n      // TODO: check if this works: it's more readable, but looks like it could swallow memory over time\n      let previousPosition = createVector(\n        previous.x + previous.width * 0.5,\n        previous.y + previous.height * 0.5\n      );\n      let currentPosition = createVector(\n        current.x + current.width * 0.5,\n        current.y + current.height * 0.5\n      );\n      return p5.Vector.sub(currentPosition, previousPosition);\n    } else {\n      return createVector();\n    }\n  }\n}\n\n//   typedef Tracker<cv::Point2f> PointTracker;\nclass PointTracker extends Tracker {\n  constructor() {\n    super();\n  }\n}\n\nclass Follower {\n  constructor() {\n    this.dead = false;\n    this.label = 0;\n  }\n\n  setup(track) {}\n  update(track) {}\n  kill() {\n    this.dead = true;\n  }\n\n  setLabel(label) {\n    this.label = label;\n  }\n  getLabel() {\n    return this.label;\n  }\n  getDead() {\n    return this.dead;\n  }\n}\n\n// typedef Follower<cv::Rect> RectFollower;\n// typedef Follower<cv::Point2f> PointFollower;\nclass RectFollower extends Follower {\n  constructor() {\n    super();\n  }\n}\n\nclass PointFollower extends Follower {\n  constructor() {\n    super();\n  }\n}\n// FIXME: figure out the best way to handle RectTracker/PointTracker\nclass TrackerFollower extends Tracker {\n  constructor() {\n    super();\n    this.labels = [];\n    this.followers = [];\n  }\n\n  track(objects) {\n    // will this handle all types ?\n    super.track(objects);\n    // kill missing, update old\n    let labelsSize = this.labels.length;\n    for (let i = 0; i < labelsSize; i++) {\n      let curLabel = this.labels[i];\n      let curFollower = this.followers[i];\n      if (!this.existsCurrent(curLabel)) {\n        curFollower.kill();\n      } else {\n        curFollower.update(this.getCurrent(curLabel));\n      }\n    }\n    // add new\n    let newLabelsSize = this.newLabels.length;\n    for (let i = 0; i < newLabelsSize; i++) {\n      let curLabel = this.newLabels[i];\n      this.labels.push(curLabel);\n      let newFollower = new Follower();\n      this.followers.push(newFollower);\n      newFollower.setup(this.getCurrent(curLabel));\n      newFollower.setLabel(curLabel);\n    }\n    // remove dead\n    labelsSize = this.labels.length;\n    for (let i = labelsSize - 1; i >= 0; i--) {\n      if (this.followers[i].getDead()) {\n        this.followers.splice(i, 1);\n        this.labels.splice(i, 1);\n      }\n    }\n    return this.labels;\n  }\n\n  getFollowers() {\n    return this.followers;\n  }\n}\n\n// template <class F> class RectTrackerFollower : public TrackerFollower<cv::Rect, F> {};\n// template <class F> class PointTrackerFollower : public TrackerFollower<cv::Point2f, F> {};\nclass RectTrackerFollower extends TrackerFollower {\n  constructor() {\n    super();\n  }\n}\nclass PointTrackerFollower extends TrackerFollower {\n  constructor() {\n    super();\n  }\n}\n\nexport {\n  TrackedObject,\n  Tracker,\n  PointTracker,\n  RectTracker,\n  Follower,\n  RectFollower,\n  PointFollower,\n  TrackerFollower,\n  RectTrackerFollower,\n  PointTrackerFollower,\n};\n","const DifferenceMode = { ABSDIFF: 0, BRIGHTER: 1, DARKER: 2 };\n\nclass RunningBackground {\n  constructor(width, height) {\n    this.learningRate = 0.0001;\n    this.learningTime = 900.0;\n    this.useLearningTime = false;\n    this.thresholdValue = 26;\n    this.ignoreForeground = false;\n    this.needToReset = false;\n    this.differenceMode = DifferenceMode.ABSDIFF;\n    this.accumulator = new cv.Mat();\n    this.background = cv.Mat.zeros(height, width, cv.CV_32F);\n    this.foreground = cv.Mat.zeros(height, width, cv.CV_32F);\n    this.foregroundGray = cv.Mat.zeros(height, width, cv.CV_32F);\n  }\n\n  update(frame, thresholded) {\n    if (this.needToReset || this.accumulator.empty()) {\n      this.needToReset = false;\n      // frame.convertTo(this.accumulator, cv.CV_32F);\n      frame.copyTo(this.accumulator);\n    }\n\n    this.accumulator.convertTo(this.background, cv.CV_8U);\n    switch (this.differenceMode) {\n      case DifferenceMode.ABSDIFF:\n        cv.absdiff(this.background, frame, this.foreground);\n        break;\n      case DifferenceMode.BRIGHTER:\n        cv.subtract(frame, this.background, this.foreground);\n        break;\n      case DifferenceMode.DARKER:\n        cv.subtract(this.background, frame, this.foreground);\n        break;\n    }\n\n    p5.cv.copyGray(this.foreground, this.foregroundGray);\n    let thresholdMode = this.ignoreForeground\n      ? cv.THRESH_BINARY_INV\n      : cv.THRESH_BINARY;\n    cv.threshold(\n      this.foregroundGray,\n      thresholded,\n      this.thresholdValue,\n      255,\n      thresholdMode\n    );\n    // FIXME is this needed ?\n    let curLearningRate = float(this.learningRate);\n    if (this.useLearningTime) {\n      // FIXME: this needs more love\n      curLearningRate = pow(\n        1 - this.thresholdValue / 255,\n        1 / float(this.learningRate)\n      );\n    }\n    if (this.ignoreForeground) {\n      //   TODO: finish this: add mask\n      p5.cv.accumulateWeighted(frame, this.accumulator, curLearningRate);\n      // cv.bitwise_not(this.thresholded, this.thresholded);\n    } else {\n      p5.cv.accumulateWeighted(frame, this.accumulator, curLearningRate);\n    }\n  }\n\n  getPresence() {\n    return cv.mean(this.foreground).data[0] / 255.0;\n  }\n\n  setThresholdValue(thresholdValue) {\n    this.thresholdValue = thresholdValue;\n  }\n\n  setLearningRate(learningRate) {\n    this.learningRate = learningRate;\n    this.useLearningTime = false;\n  }\n\n  setLearningTime(learningTime) {\n    this.learningTime = learningTime;\n    this.useLearningTime = true;\n  }\n\n  setIgnoreForeground(ignoreForeground) {\n    this.ignoreForeground = ignoreForeground;\n  }\n\n  setDifferenceMode(differenceMode) {\n    this.differenceMode = differenceMode;\n  }\n\n  reset() {\n    this.needToReset = true;\n  }\n}\n\nexport default RunningBackground;\n","class ObjectFinder {\n  constructor() {\n    this.rescale = 1;\n    this.multiScaleFactor = 1.1;\n    this.minNeighbors = 3;\n    this.minSizeScale = new cv.Size();\n    this.maxSizeScale = new cv.Size(1, 1);\n    this.useHistogramEqualization = true;\n    this.cannyPrunning = false;\n    this.findBiggestObject = false;\n\n    this.gray = new cv.Mat();\n    this.graySmall = new cv.Mat();\n    this.classifier = new cv.CascadeClassifier();\n    // vector<Rect>\n    this.objects = [];\n    this.tracker = new RectTracker();\n  }\n\n  setup(cascadeFilename) {\n    // FIXME: handle load errors\n    this.classifier.load(cascadeFilename);\n  }\n\n  update(newFrameMat) {\n    if (this.classifier.empty()) {\n      return;\n    }\n    if (newFrameMat.channels() === 1) {\n      this.gray = newFrameMat;\n    } else {\n      p5.cv.copyGray(newFrameMat, this.gray);\n    }\n    p5.cv.resizeToScale(this.gray, this.graySmall, this.rescale, this.rescale);\n\n    if (this.useHistogramEqualization) {\n      p5.cv.equalizeHist(this.graySmall);\n    }\n    let minSize = new cv.Size(),\n      maxSize = new cv.Size();\n    let minSide = min(this.graySmall.rows, this.graySmall.cols);\n    if (this.minSizeScale > 0) {\n      let side = this.minSizeScale * minSide;\n      minSize.width = side;\n      minSize.height = side;\n    }\n    if (this.maxSizeScale < 1) {\n      let side = this.maxSizeScale * minSide;\n      // maxSize = new cv.Size(side, side);\n      maxSize.width = side;\n      maxSize.height = side;\n    }\n\n    let rectVector = new cv.RectVector();\n    this.classifier.detectMultiScale(\n      this.graySmall,\n      rectVector,\n      this.multiScaleFactor,\n      this.minNeighbors,\n      (this.cannyPruning ? cv.CASCADE_DO_CANNY_PRUNING : 0) |\n        (this.findBiggestObject\n          ? cv.CASCADE_FIND_BIGGEST_OBJECT | cv.CASCADE_DO_ROUGH_SEARCH\n          : 0),\n      minSize,\n      maxSize\n    );\n\n    this.objects.length = 0;\n    p5.cv.cvRectVectorToArray(rectVector, this.objects);\n    rectVector.delete();\n    let objectsSize = this.objects.length;\n    let rect;\n    for (let i = 0; i < objectsSize; i++) {\n      rect = this.objects[i];\n      // FIXME check if this is meant to be /= or *=\n      (rect.width /= this.rescale), (rect.height /= this.rescale);\n      (rect.x /= this.rescale), (rect.y /= this.rescale);\n      // // FIXME check if the above does the job by reference of we need the bellow re-assingment\n      this.objects[i] = rect;\n    }\n    this.tracker.track(this.objects);\n  }\n\n  size() {\n    return this.objects.length;\n  }\n\n  getObject(i) {\n    return this.objects[i];\n  }\n\n  getObjectSmoothed(i) {\n    return this.tracker.getSmoothed(this.getLabel(i));\n  }\n\n  getVelocity(i) {\n    return this.tracker.getVelocity(i);\n  }\n\n  getLabel(i) {\n    return this.tracker.getCurrentLabels()[i];\n  }\n\n  getTracker() {\n    return this.tracker;\n  }\n\n  draw() {\n    push();\n    noFill();\n    stroke(0, 192, 0);\n    let size = this.size();\n    let object;\n    for (let i = 0; i < size; i++) {\n      object = this.getObject(i);\n      rect(object.x, object.y, object.width, object.height);\n      text(this.getLabel(i), object.x, object.y - 3);\n    }\n    pop();\n  }\n\n  setPreset(preset) {\n    if (preset === ObjectFinder.FAST) {\n      this.setRescale(0.25);\n      this.setMinNeighbors(2);\n      this.setMultiScaleFactor(1.2);\n      this.setMinSizeScale(0.25);\n      this.setMaxSizeScale(0.75);\n      this.setCannyPruning(true);\n      this.setFindBiggestObject(false);\n    } else if (preset === ObjectFinder.ACCURATE) {\n      this.setRescale(0.5);\n      this.setMinNeighbors(6);\n      this.setMultiScaleFactor(1.02);\n      this.setMinSizeScale(0.1);\n      this.setMaxSizeScale(1);\n      this.setCannyPruning(true);\n      this.setFindBiggestObject(false);\n    } else if (preset === ObjectFinder.SENSITIVE) {\n      this.setRescale(0.5);\n      this.setMinNeighbors(1);\n      this.setMultiScaleFactor(1.02);\n      this.setMinSizeScale(0.1);\n      this.setMaxSizeScale(1);\n      this.setCannyPruning(false);\n      this.setFindBiggestObject(false);\n    }\n  }\n\n  setRescale(rescale) {\n    this.rescale = rescale;\n  }\n\n  setMinNeighbors(minNeighbors) {\n    this.minNeighbors = minNeighbors;\n  }\n\n  setMultiScaleFactor(multiScaleFactor) {\n    this.multiScaleFactor = multiScaleFactor;\n  }\n\n  setCannyPruning(cannyPruning) {\n    this.cannyPrunning = cannyPruning;\n  }\n\n  setFindBiggestObject(findBiggestObject) {\n    this.findBiggestObject = findBiggestObject;\n  }\n\n  setUseHistogramEqualization(useHistogramEqualization) {\n    this.useHistogramEqualization = useHistogramEqualization;\n  }\n\n  setMinSizeScale(minSizeScale) {\n    this.minSizeScale = minSizeScale;\n  }\n\n  setMaxSizeScale(maxSizeScale) {\n    this.maxSizeScale = maxSizeScale;\n  }\n}\n\nObjectFinder.FAST = 0;\nObjectFinder.ACCURATE = 1;\nObjectFinder.SENSITIVE = 2;\n\nexport default ObjectFinder;\n","class Flow {\n  constructor() {\n    this.last = new cv.Mat();\n    this.curr = new cv.Mat();\n    this.hasFlow = false;\n  }\n\n  //call these functions to calculate flow on sequential images.\n  //After this call the flow field will be populated and\n  //subsequent calls to getFlow() will be updated\n\n  //call with two contiguous images\n  calcOpticalFlowTo(lastMat, currentMat) {\n    if (lastMat.channels() === 1 && currentMat.channels() === 1) {\n      this.calcFlow(lastMat, currentMat);\n    } else {\n      p5.cv.copyGray(lastMat, this.last);\n      p5.cv.copyGray(currentMat, this.curr);\n      this.calcFlow(this.last, this.curr);\n    }\n    this.hasFlow = true;\n  }\n\n  //call with subsequent images to do running optical flow.\n  //the Flow class internally stores the last image for convenience\n  calcOpticalFlow(currentMat) {\n    p5.cv.copyGray(currentMat, this.curr);\n    let lastSize = this.last.size();\n    let currSize = this.curr.size();\n    if (\n      lastSize.width === currSize.width &&\n      lastSize.height === currSize.height\n    ) {\n      this.calcFlow(this.last, this.curr);\n      this.hasFlow = true;\n    }\n    p5.cv.swap(this.curr, this.last);\n  }\n\n  draw(x, y, renderWidth, renderHeight) {\n    x = x || 0;\n    y = y || 0;\n    renderWidth = renderWidth || width;\n    renderHeight = renderHeight || height;\n    if (this.hasFlow) {\n      this.drawFlow(x, y, width, height);\n    }\n  }\n\n  drawRect(rect) {\n    if (this.hasFlow) {\n      this.drawFlow(rect.x, rect.y, rect.width, rect.height);\n    }\n  }\n\n  getWidth() {\n    return this.curr.cols;\n  }\n\n  getHeight() {\n    return this.curr.rows;\n  }\n\n  resetFlow() {\n    this.last.setTo(p5.cv.ZERO_SCALAR);\n    this.curr.setTo(p5.cv.ZERO_SCALAR);\n    this.hasFlow = false;\n  }\n\n  // for subclass override\n  calcFlow(prevMat, nextMat) {}\n}\n\n//there are two implementations of Flow\n//use Farneback for a dense flow field,\n//use PyrLK for specific features\n\n//see http://opencv.willowgarage.com/documentation/cpp/motion_analysis_and_object_tracking.html\n//for more info on the meaning of these parameters\n\nclass FlowPyrLK extends Flow {\n  constructor() {\n    super();\n    this.prevPts = new cv.Mat();\n    this.nextPts = new cv.Mat();\n\n    //LK feature finding parameters\n    this.windowSize = new cv.Size(32, 32);\n    this.maxLevel = 3;\n    this.maxFeatures = 200;\n\n    // parameters for ShiTomasi corner detection\n    this.maxCorners = 30;\n    this.blockSize = 7;\n    this.qualityLevel = 0.01;\n    //min distance for PyrLK\n    this.minDistance = 4;\n\n    this.criteria = new cv.TermCriteria(\n      cv.TERM_CRITERIA_EPS | cv.TERM_CRITERIA_COUNT,\n      10,\n      0.03\n    );\n\n    //pyramid levels\n    this.pyramidLevels = 10;\n\n    this.calcFeaturesNextFrame = true;\n\n    //pyramid + err/status data\n    this.pyramid = new cv.Mat();\n    this.prevPyramid = new cv.Mat();\n    this.status = new cv.Mat();\n    this.err = new cv.Mat();\n  }\n\n  //flow parameters\n  setMinDistance(minDistance) {\n    this.minDistance = minDistance;\n  }\n  setWindowSize(winSize) {\n    this.windowSize.width = winSize;\n    this.windowSize.height = winSize;\n  }\n\n  //feature finding parameters\n  setMaxLevel(maxLevel) {\n    this.maxLevel = maxLevel;\n  }\n\n  setMaxFeatures(maxFeatures) {\n    this.maxFeatures = maxFeatures;\n  }\n\n  setQualityLevel(qualityLevel) {\n    this.qualityLevel = qualityLevel;\n  }\n\n  setPyramidLevels(levels) {\n    this.pyramidLevels = levels;\n  }\n\n  //returns tracking features for this image\n  getFeatures() {\n    // FIXME: make sure these are cv.Point like\n    return p5.cv.cvFeaturesToPoints(this.prevPts);\n  }\n\n  getCurrent() {\n    let result = [];\n    for (let i = 0; i < this.nextPts.rows; i++) {\n      if (this.status.data[i]) {\n        result.push(p5.cv.getFeatureAsPoint(this.nextPts, i));\n      }\n    }\n    return result;\n  }\n\n  getMotion() {\n    let result = [];\n    let featuresSize = this.prevPts.rows;\n    for (let i = 0; i < featuresSize; i++) {\n      if (this.status.data[i]) {\n        result.push(\n          cv.Point.sub(\n            p5.cv.getFeatureAsPoint(this.nextPts, i),\n            p5.cv.getFeatureAsPoint(this.prevPts, i)\n          )\n        );\n      }\n    }\n    return result;\n  }\n\n  // recalculates features to track\n  resetFeaturesToTrack() {\n    this.calcFeaturesNextFrame = true;\n  }\n  setFeaturesToTrack(features) {\n    this.nextPts = features;\n    this.calcFeaturesNextFrame = false;\n  }\n  resetFlow() {\n    super.resetFlow();\n    this.resetFeaturesToTrack();\n    this.prevPts = new cv.Mat();\n  }\n\n  drawFlow(drawX, drawY, drawWidth, drawHeight) {\n    let scaleX = drawWidth / width;\n    let scaleY = drawHeight / height;\n    let prevPtsSize = this.prevPts.rows;\n\n    beginShape(LINES);\n    for (let i = 0; i < prevPtsSize; i++) {\n      if (this.status.data[i]) {\n        vertex(\n          this.prevPts.data32F[i * 2] * scaleX + drawX,\n          this.prevPts.data32F[i * 2 + 1] * scaleY + drawY,\n          9\n        );\n\n        vertex(\n          this.nextPts.data32F[i * 2] * scaleX + drawX,\n          this.nextPts.data32F[i * 2 + 1] * scaleY + drawY,\n          9\n        );\n      }\n    }\n    endShape();\n  }\n\n  calcFlow(prevMat, nextMat) {\n    if (!this.nextPts.empty() || this.calcFeaturesNextFrame) {\n      if (this.calcFeaturesNextFrame) {\n        this.calcFeaturesToTrack(this.prevPts, nextMat);\n        this.calcFeaturesNextFrame = false;\n      } else {\n        p5.cv.swap(this.prevPts, this.nextPts);\n      }\n      this.nextPts.setTo(p5.cv.ZERO_SCALAR);\n\n      cv.calcOpticalFlowPyrLK(\n        prevMat,\n        nextMat,\n        this.prevPts,\n        this.nextPts,\n        this.status,\n        this.err,\n        this.windowSize,\n        this.maxLevel\n      );\n\n      // cv.calcOpticalFlowPyrLK(oldGray, frameGray, p0, p1, st, err, winSize, maxLevel, criteria);\n\n      // status.resize(nextPts.size(),0);\n    } else {\n      this.calcFeaturesToTrack(this.nextPts, nextMat);\n    }\n  }\n\n  calcFeaturesToTrack(features, nextMat) {\n    /* goodFeaturesToTrack arguments\n\n        image  single-channel 8-bit input image.\n        edges  output edge map; it has the same size and type as image .\n        threshold1  first threshold for the hysteresis procedure.\n        threshold2  second threshold for the hysteresis procedure.\n        apertureSize  aperture size for the Sobel() operator.\n        L2gradient - a flag, indicating whether a more accurate L_2 norm =\\sqrt{(dI/dx)^2 + (dI/dy)^2} should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default L_1 norm =|dI/dx|+|dI/dy| is enough ( L2gradient=false ).\n        \n        cv.goodFeaturesToTrack(oldGray, p0, maxCorners, qualityLevel, minDistance, none, blockSize);\n\n        */\n    cv.goodFeaturesToTrack(\n      nextMat,\n      features,\n      this.maxFeatures,\n      this.qualityLevel,\n      this.minDistance\n    );\n  }\n}\n\nclass FlowFarneback extends Flow {\n  constructor() {\n    super();\n\n    this.flow = new cv.Mat();\n\n    this.pyramidScale = 0.5;\n    this.numLevels = 4;\n    this.windowSize = 8;\n    this.numIterations = 2;\n    this.polyN = 7;\n    this.polySigma = 1.5;\n    this.farnebackGaussian = false;\n    this.renderStep = 60;\n\n    // let frame2 = new cv.Mat(video.height, video.width, cv.CV_8UC4);\n    // let next = new cv.Mat(video.height, video.width, cv.CV_8UC1);\n    // let flow = new cv.Mat(video.height, video.width, cv.CV_32FC2);\n    // let flowVec = new cv.MatVector();\n    // let mag = new cv.Mat(video.height, video.width, cv.CV_32FC1);\n    // let ang = new cv.Mat(video.height, video.width, cv.CV_32FC1);\n    // let rgb = new cv.Mat(video.height, video.width, cv.CV_8UC3);\n  }\n\n  setPyramidScale(scale) {\n    if (scale < 0.0 || scale >= 1.0) {\n      console.warn(\n        'FlowFarneback::setPyramidScale',\n        'setting scale to a number outside of 0 - 1'\n      );\n      scale = constrain(scale, 0.0, 1.0);\n    }\n    this.pyramidScale = scale;\n  }\n  setNumLevels(levels) {\n    this.numLevels = levels;\n  }\n  setWindowSize(winSize) {\n    this.windowSize = winSize;\n  }\n  setNumIterations(iterations) {\n    this.numIterations = iterations;\n  }\n  setPolyN(polyN) {\n    this.polyN = polyN;\n  }\n  setPolySigma(polySigma) {\n    this.polySigma = polySigma;\n  }\n  setUseGaussian(gaussian) {\n    this.farnebackGaussian = gaussian;\n  }\n\n  //call this if you switch to a new video file to reset internal caches\n  resetFlow() {\n    super.resetFlow();\n    this.flow.setTo(p5.cv.ZERO_SCALAR);\n  }\n\n  calcFlow(prevMat, nextMat) {\n    let flags = 0;\n    if (this.hasFlow) {\n      flags = cv.OPTFLOW_USE_INITIAL_FLOW;\n    }\n    if (this.farnebackGaussian) {\n      flags |= cv.OPTFLOW_FARNEBACK_GAUSSIAN;\n    }\n    // cv.calcOpticalFlowFarneback(prevMat, nextMat, this.flow, 0.5, 3, 15, 3, 5, 1.2, 0);\n\n    cv.calcOpticalFlowFarneback(\n      prevMat,\n      nextMat,\n      this.flow,\n      this.pyramidScale,\n      this.numLevels,\n      this.windowSize,\n      this.numIterations,\n      this.polyN,\n      this.polySigma,\n      flags\n    );\n  }\n\n  getFlow() {\n    if (!hasFlow) {\n      this.flow = cv.Mat.zeros(1, 1, CV_32FC2);\n    }\n    return this.flow;\n  }\n\n  getTotalFlow() {\n    return this.getTotalFlowInRegion(0, 0, this.flow.cols, this.flow.rows);\n  }\n  getAverageFlow() {\n    return this.getAverageFlowInRegion(0, 0, this.flow.cols, this.flow.rows);\n  }\n  getFlowOffset(x, y) {\n    if (!this.hasFlow) {\n      return new cv.Point();\n    }\n    // (x + (y * w) ) * channels()\n    let xIndex = (x + y * this.flow.cols) * 2;\n    let yIndex = xIndex + 1;\n    return { x: this.flow.data32F[xIndex], y: this.flow.data32F[yIndex] };\n  }\n  getFlowPosition(x, y) {\n    let position = this.getFlowOffset(x, y);\n    position.x += x;\n    position.y += y;\n    return position;\n  }\n  getTotalFlowInRegion(regionX, regionY, regionWidth, regionHeight) {\n    if (!this.hasFlow) {\n      return new cv.Point(0, 0);\n    }\n\n    let x = 0;\n    let y = 0;\n    let total = this.flow.total();\n    let data = this.flow.data32F;\n\n    for (let i = 0; i < total; i++) {\n      let xIndex = i * 2;\n      let yIndex = i * 2 + 1;\n      x += data[xIndex];\n      y += data[yIndex];\n    }\n\n    return { x: x, y: y };\n  }\n\n  getAverageFlowInRegion(regionX, regionY, regionWidth, regionHeight) {\n    let flow = this.getTotalFlowInRegion(\n      regionX,\n      regionY,\n      regionWidth,\n      regionHeight\n    );\n    flow.x /= regionWidth;\n    flow.y /= regionHeight;\n    return flow;\n  }\n\n  drawFlow(rectX, rectY, rectWidth, rectHeight) {\n    if (!this.hasFlow) {\n      return;\n    }\n    let scaleX = rectWidth / this.flow.cols;\n    let scaleY = rectHeight / this.flow.rows;\n    console.log(rectWidth, rectHeight);\n    beginShape(LINES);\n    let flowPosition;\n    for (let y = 0; y < this.flow.rows; y += this.renderStep) {\n      for (let x = 0; x < this.flow.cols; x += this.renderStep) {\n        flowPosition = this.getFlowPosition(x, y);\n        vertex(x * scaleX + rectX, y * scaleY + rectY);\n        vertex(\n          flowPosition.x * scaleX + rectX,\n          flowPosition.y * scaleY + rectY\n        );\n      }\n    }\n    endShape();\n  }\n}\n\nclass Graph {\n  constructor(historyLength, minValue, maxValue) {\n    this.minValue = minValue;\n    this.maxValue = maxValue;\n    this.historyLength = historyLength;\n    this.history = new Float32Array(historyLength);\n    this.index = 0;\n  }\n\n  addSample(sample) {\n    this.history[this.index] = sample;\n    this.index = (this.index + 1) % this.historyLength;\n  }\n\n  getNormalizedSample(offset) {\n    var i = (this.index + offset) % this.historyLength;\n    var range = this.maxValue - this.minValue;\n    return (this.history[i] - this.minValue) / range;\n  }\n\n  draw(width, height) {\n    push();\n    noFill();\n    strokeWeight(1);\n    beginShape();\n    var range = this.maxValue - this.minValue;\n    for (var offset = 0; offset < this.historyLength; offset++) {\n      var i = (this.index + offset) % this.historyLength;\n      var x = (offset * width) / this.historyLength;\n      var normalized = (this.history[i] - this.minValue) / range;\n      var y = height - normalized * height;\n      vertex(x, y);\n    }\n    endShape();\n    pop();\n  }\n}\n\np5.cv.samePixels = function (a1, a2, stride, n) {\n  for (var i = 0; i < n; i += stride) {\n    if (a1[i] !== a2[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n// TODO: review all functions that make new matrices and cleanup\np5.cv.same = function (matA, matB) {\n  let diff = new cv.Mat();\n  let matAGray = new cv.Mat();\n  let matBGray = new cv.Mat();\n  p5.cv.copyGray(matA, matAGray);\n  p5.cv.copyGray(matB, matBGray);\n  cv.absdiff(matAGray, matBGray, diff);\n  let same = cv.countNonZero(diff) === 0;\n  diff.delete();\n  matAGray.delete();\n  matBGray.delete();\n  return same;\n};\n\n// copied from https://github.com/anvaka/oflow\n\nclass OFlow extends Flow {\n  constructor() {\n    super();\n    this.step = 8;\n    this.flow = null;\n\n    this.uMotionGraph = new Graph(100, -this.step / 2, +this.step / 2);\n    this.vMotionGraph = new Graph(100, -this.step / 2, +this.step / 2);\n  }\n\n  calcOpticalFlow(currentMat) {\n    this.curr = currentMat;\n    let lastSize = this.last.size();\n    let currSize = this.curr.size();\n    if (\n      lastSize.width === currSize.width &&\n      lastSize.height === currSize.height\n    ) {\n      // TODO: profile CPU improvements\n      // cheap way to ignore duplicate frames\n      if (!p5.cv.samePixels(this.last.data, currentMat.data, 4, width)) {\n        this.calcFlow(this.last, this.curr);\n        this.hasFlow = true;\n      }\n    }\n    p5.cv.swap(this.curr, this.last);\n  }\n\n  // TODO: this could be simpler with OpenCV operations instead of individual byte access ?\n  // assumes rgba images, but only uses one channel\n  calcFlow(prevMat, nextMat) {\n    if (prevMat.type() !== cv.CV_8UC4 || nextMat.type() !== cv.CV_8UC4) {\n      console.warn('currently supporting only RGBA images');\n      this.hasFlow = false;\n      return;\n    }\n\n    let width = prevMat.cols;\n    let height = prevMat.rows;\n\n    let newImage = nextMat.data;\n    let oldImage = prevMat.data;\n\n    var zones = [];\n    var step = this.step;\n    var winStep = step * 2 + 1;\n\n    var A2, A1B2, B1, C1, C2;\n    var u, v, uu, vv;\n    uu = vv = 0;\n    var wMax = width - step - 1;\n    var hMax = height - step - 1;\n    var globalY, globalX, localY, localX;\n\n    for (globalY = step + 1; globalY < hMax; globalY += winStep) {\n      for (globalX = step + 1; globalX < wMax; globalX += winStep) {\n        A2 = A1B2 = B1 = C1 = C2 = 0;\n        // console.log('here',globalX,globalY);\n        for (localY = -step; localY <= step; localY++) {\n          for (localX = -step; localX <= step; localX++) {\n            var address = (globalY + localY) * width + globalX + localX;\n\n            var gradX =\n              newImage[(address - 1) * 4] - newImage[(address + 1) * 4];\n\n            var gradY =\n              newImage[(address - width) * 4] - newImage[(address + width) * 4];\n            var gradT = oldImage[address * 4] - newImage[address * 4];\n\n            A2 += gradX * gradX;\n            A1B2 += gradX * gradY;\n            B1 += gradY * gradY;\n            C2 += gradX * gradT;\n            C1 += gradY * gradT;\n          }\n        }\n\n        var delta = A1B2 * A1B2 - A2 * B1;\n\n        if (delta !== 0) {\n          /* system is not singular - solving by Kramer method */\n          var Idelta = step / delta;\n          var deltaX = -(C1 * A1B2 - C2 * B1);\n          var deltaY = -(A1B2 * C2 - A2 * C1);\n\n          u = deltaX * Idelta;\n          v = deltaY * Idelta;\n        } else {\n          /* singular system - find optical flow in gradient direction */\n          var norm = (A1B2 + A2) * (A1B2 + A2) + (B1 + A1B2) * (B1 + A1B2);\n          if (norm !== 0) {\n            var IGradNorm = step / norm;\n            var temp = -(C1 + C2) * IGradNorm;\n\n            u = (A1B2 + A2) * temp;\n            v = (B1 + A1B2) * temp;\n          } else {\n            u = v = 0;\n          }\n        }\n\n        if (-winStep < u && u < winStep && -winStep < v && v < winStep) {\n          uu += u;\n          vv += v;\n          zones.push(new cv.Rect(globalX, globalY, u, v));\n        }\n      }\n    }\n\n    this.flow = {\n      zones: zones,\n      u: uu / zones.length,\n      v: vv / zones.length,\n    };\n\n    this.hasFlow = true;\n\n    return this.flow;\n  }\n\n  drawFlow(rectX, rectY, rectWidth, rectHeight) {\n    if (!this.hasFlow) {\n      return;\n    }\n    let scaleX = rectWidth / this.curr.cols;\n    let scaleY = rectHeight / this.curr.rows;\n\n    if (this.flow && this.flow.u !== 0 && this.flow.v !== 0) {\n      this.uMotionGraph.addSample(this.flow.u);\n      this.vMotionGraph.addSample(this.flow.v);\n\n      strokeWeight(2);\n\n      let step = this.step;\n      this.flow.zones.forEach(function (zone) {\n        stroke(\n          map(zone.width, -step, +step, 0, 255),\n          map(zone.height, -step, +step, 0, 255),\n          128\n        );\n        line(\n          zone.x * scaleX + rectX,\n          zone.y * scaleY + rectY,\n          (zone.x + zone.width) * scaleX + rectX,\n          (zone.y + zone.height) * scaleY + rectY\n        );\n      });\n    }\n  }\n\n  plotGraphs(rectX, rectY, rectWidth, rectHeight) {\n    if (!this.hasFlow) {\n      return;\n    }\n    if (this.flow && this.flow.u !== 0 && this.flow.v !== 0) {\n      // draw left-right motion\n      this.uMotionGraph.draw(rectWidth, rectHeight / 2);\n      line(\n        rectX,\n        rectY + rectHeight / 4,\n        rectX + rectWidth,\n        rectY + rectHeight / 4\n      );\n\n      // draw up-down motion\n      translate(0, rectHeight / 2);\n      this.vMotionGraph.draw(rectWidth, rectHeight / 2);\n      line(\n        rectX,\n        rectY + rectHeight / 4,\n        rectX + rectWidth,\n        rectY + rectHeight / 4\n      );\n    }\n  }\n}\n\nexport { Flow, FlowPyrLK, FlowFarneback, OFlow, Graph };\n","p5.cv.TrackingColorMode = {\n  TRACK_COLOR_RGB: 0,\n  TRACK_COLOR_HSV: 1,\n  TRACK_COLOR_H: 2,\n  TRACK_COLOR_HS: 3,\n};\n\nclass ContourFinder {\n  constructor() {\n    this.hsvBuffer = new cv.Mat();\n    this.thresh = new cv.Mat();\n\n    this.autoThreshold = true;\n    this.invert = false;\n    this.simplify = true;\n\n    this.thresholdValue = 128;\n    this.thresholdValueMax = 255;\n\n    this.useTargetColor = false;\n    this.trackingColorMode = p5.cv.TrackingColorMode.TRACK_COLOR_HSV;\n    this.targetColor = color(0);\n\n    this.minArea = 0;\n    this.maxArea = Number.POSITIVE_INFINITY;\n\n    this.minAreaNorm = false;\n    this.maxAreaNorm = false;\n    // FIXME check of this needs will work as [] or Mat\n    this.contours = [];\n    this.polylines = [];\n\n    this.tracker = new RectTracker();\n    this.boundingRects = [];\n    this.holes = [];\n\n    this.contourFindingMode = cv.RETR_EXTERNAL;\n    this.sortBySize = false;\n\n    this.resetMinArea();\n    this.resetMaxArea();\n  }\n\n  findContours(sourceMat) {\n    // threshold the image using a tracked color or just binary grayscale\n    if (this.useTargetColor) {\n      // Scalar is equivalent to [0, 0, 0, 0]\n      let offset = [\n        this.thresholdValue,\n        this.thresholdValue,\n        this.thresholdValue,\n        0,\n      ];\n      let base = p5.cv.colorToCvScalar(this.targetColor);\n      if (this.trackingColorMode === p5.cv.TrackingColorMode.TRACK_COLOR_RGB) {\n        //inRange(img, base - offset, base + offset, thresh);\n        // cv.inRange(\n        //   sourceMat,\n        //   cv.Scalar.sub(base, offset),\n        //   cv.Scalar.add(base + offset),\n        //   this.thresh\n        // );\n        let lowerb = new cv.Mat(\n          sourceMat.rows,\n          sourceMat.cols,\n          sourceMat.type(),\n          cv.Scalar.sub(base, offset)\n        );\n        let upperb = new cv.Mat(\n          sourceMat.rows,\n          sourceMat.cols,\n          sourceMat.type(),\n          cv.Scalar.add(base, offset)\n        );\n        cv.inRange(sourceMat, lowerb, upperb, this.thresh);\n        lowerb.delete();\n        upperb.delete();\n      } else {\n        // all the HSV modes are broken incorrect,\n        // because opencv uses hue 0-180 not 0-255\n        // which means that the math doesn't wrap.\n        if (this.trackingColorMode === p5.cv.TrackingColorMode.TRACK_COLOR_H) {\n          offset[1] = 255;\n          offset[2] = 255;\n        }\n        if (this.trackingColorMode === p5.cv.TrackingColorMode.TRACK_COLOR_HS) {\n          offset[2] = 255;\n        }\n        if (!p5.cv.getAllocated(this.hsvBuffer)) {\n          p5.cv.imitate(this.hsvBuffer, sourceMat);\n        }\n        cv.cvtColor(sourceMat, this.hsvBuffer, cv.COLOR_RGBA2RGB);\n        cv.cvtColor(this.hsvBuffer, this.hsvBuffer, cv.COLOR_RGB2HSV);\n        base = p5.cv.convertSingleColor(this.targetColor, cv.COLOR_RGBA2RGB);\n        base = p5.cv.convertSingleColor(base, cv.COLOR_RGB2HSV);\n\n        let lowerb = new cv.Mat(\n          this.hsvBuffer.rows,\n          this.hsvBuffer.cols,\n          this.hsvBuffer.type(),\n          cv.Scalar.sub(base, offset)\n        );\n        let upperb = new cv.Mat(\n          this.hsvBuffer.rows,\n          this.hsvBuffer.cols,\n          this.hsvBuffer.type(),\n          cv.Scalar.add(base, offset)\n        );\n        cv.inRange(this.hsvBuffer, lowerb, upperb, this.thresh);\n        lowerb.delete();\n        upperb.delete();\n      }\n    } else {\n      p5.cv.copyGray(sourceMat, this.thresh);\n    }\n\n    if (this.autoThreshold) {\n      p5.cv.threshold(this.thresh, this.thresholdValue, this.invert);\n    }\n\n    // run the contour finder\n    let allContours = new cv.MatVector();\n    let hierarchy = new cv.Mat();\n    let simplifyMode = this.simplify\n      ? cv.CHAIN_APPROX_SIMPLE\n      : cv.CHAIN_APPROX_NONE;\n    cv.findContours(\n      this.thresh,\n      allContours,\n      hierarchy,\n      this.contourFindingMode,\n      simplifyMode\n    );\n\n    // filter the contours\n    let needMinFilter = this.minArea > 0;\n    let needMaxFilter = this.maxAreaNorm\n      ? this.maxArea < 1\n      : this.maxArea < Number.POSITIVE_INFINITY;\n    let allIndices = [];\n    let allAreas = [];\n    let allHoles = [];\n    if (needMinFilter || needMaxFilter) {\n      let imgArea = sourceMat.rows * sourceMat.cols;\n      let imgMinArea = this.minAreaNorm ? this.minArea * imgArea : this.minArea;\n      let imgMaxArea = this.maxAreaNorm ? this.maxArea * imgArea : this.maxArea;\n\n      for (let i = 0; i < allContours.size(); i++) {\n        let curArea = cv.contourArea(allContours.get(i), true);\n        let hole = true;\n        if (curArea < 0) {\n          curArea = -curArea;\n          hole = false;\n        }\n        allHoles.push(hole);\n        allAreas.push(curArea);\n        if (\n          (!needMinFilter || curArea >= imgMinArea) &&\n          (!needMaxFilter || curArea <= imgMaxArea)\n        ) {\n          allIndices.push(i);\n        }\n      }\n    } else {\n      for (let i = 0; i < allContours.size(); i++) {\n        if (this.sortBySize) {\n          allAreas.push(cv.contourArea(allContours.get(i)));\n        }\n        allIndices.push(i);\n      }\n    }\n\n    if (allIndices.length > 1 && this.sortBySize) {\n      // Sort contour indices, based on a separate vector of areas.\n      // Sort contour indices into decreasing order, based on a vector of\n      // contour areas.  Later, we will use these indices to order the\n      // contours (which are stored in a separate vector).\n      /* bool operator()(size_t a, size_t b) const\n            {\n                return mAreaVec[a] > mAreaVec[b];\n            } */\n      allIndices.sort((a, b) => {\n        if (allAreas[a] > allAreas[b]) return 1;\n        if (allAreas[a] < allAreas[b]) return -1;\n        return 0;\n      });\n    }\n\n    // generate polylines and bounding boxes from the contours\n    this.contours.length = 0;\n    this.polylines.length = 0;\n    this.boundingRects.length = 0;\n    this.holes.length = 0;\n    let allIndicesSize = allIndices.length;\n    for (let i = 0; i < allIndicesSize; i++) {\n      let contour = allContours.get(allIndices[i]);\n      this.contours.push(contour);\n      this.polylines.push(p5.cv.cvPointsToVectors(contour));\n      this.boundingRects.push(cv.boundingRect(contour));\n      this.holes.push(allHoles[allIndices[i]]);\n    }\n\n    // track bounding boxes\n    this.tracker.track(this.boundingRects);\n  }\n\n  setFindHoles(findHoles) {\n    if (findHoles) {\n      this.contourFindingMode = cv.RETR_LIST;\n    } else {\n      this.contourFindingMode = cv.RETR_EXTERNAL;\n    }\n  }\n\n  setSortBySize(sizeSort) {\n    this.sortBySize = sizeSort;\n  }\n\n  getContours() {\n    return this.contours;\n  }\n\n  getPolylines() {\n    return this.polylines;\n  }\n\n  getBoundingRects() {\n    return this.boundingRects;\n  }\n\n  size() {\n    return this.contours.length;\n  }\n\n  getContour(i) {\n    return this.contours[i];\n  }\n\n  getPolyline(i) {\n    return this.polylines[i];\n  }\n\n  getBoundingRect(i) {\n    return this.boundingRects[i];\n  }\n\n  getCenter(i) {\n    let box = this.getBoundingRect(i);\n    return new cv.Point(box.x + box.width * 0.5, box.y + box.height * 0.5);\n  }\n\n  getCentroid(i) {\n    let m = cv.moments(this.contours[i]);\n    if (m.m00 !== 0) {\n      return new cv.Point(m.m10 / m.m00, m.m01 / m.m00);\n    } else {\n      return new cvPoint(0, 0);\n    }\n  }\n\n  getAverage(i) {\n    let average = cv.mean(this.contours[i]);\n    return new cv.Point(average[0], average[1]);\n  }\n\n  getBalance(i) {\n    return cv.Point.sub(this.getCentroid(i), this.getCenter(i));\n  }\n\n  getContourArea(i) {\n    return cv.contourArea(this.contours[i]);\n  }\n\n  getArcLength(i) {\n    return cv.arcLength(this.contours[i], true);\n  }\n\n  getConvexHull(i) {\n    if (this.contours[i]) {\n      return p5.cv.getConvexHullMat(this.contours[i]);\n    }\n  }\n\n  getConvexityDefects(i) {\n    return p5.cv.convexityDefectsCv(this.contours[i]);\n  }\n\n  getMinAreaRect(i) {\n    return cv.minAreaRect(this.contours[i]);\n  }\n\n  getMinEnclosingCircle(i) {\n    return cv.minEnclosingCircle(this.contours[i]);\n  }\n\n  getFitEllipse(i) {\n    if (this.contours[i].total() < 5) {\n      return this.getMinAreaRect(i);\n    }\n    return cv.fitEllipse(this.contours[i]);\n  }\n\n  getFitQuad(i) {\n    let convexHull = this.getConvexHull(i);\n    if (!convexHull) {\n      return;\n    }\n    let quad = convexHull.clone();\n\n    const targetPoints = 4;\n    const maxIterations = 16;\n    const infinity = Number.POSITIVE_INFINITY;\n    let minEpsilon = 0;\n    let maxEpsilon = infinity;\n    let curEpsilon = 16; // good initial guess\n\n    // unbounded binary search to simplify the convex hull until it's 4 points\n    if (quad.total() > 4) {\n      for (let i = 0; i < maxIterations; i++) {\n        cv.approxPolyDP(convexHull, quad, curEpsilon, true);\n        if (quad.total() === targetPoints) {\n          break;\n        }\n        if (quad.total() > targetPoints) {\n          minEpsilon = curEpsilon;\n          if (maxEpsilon === infinity) {\n            curEpsilon = curEpsilon * 2;\n          } else {\n            curEpsilon = (maxEpsilon + minEpsilon) / 2;\n          }\n        }\n        if (quad.total() < targetPoints) {\n          maxEpsilon = curEpsilon;\n          curEpsilon = (maxEpsilon + minEpsilon) / 2;\n        }\n      }\n    }\n\n    return quad;\n  }\n\n  getHole(i) {\n    return this.holes[i];\n  }\n\n  getVelocity(i) {\n    return this.tracker.getVelocity(i);\n  }\n\n  getLabel(i) {\n    return this.tracker.getCurrentLabels()[i];\n  }\n\n  getTracker() {\n    return this.tracker;\n  }\n\n  setAutoThreshold(autoThreshold) {\n    this.autoThreshold = autoThreshold;\n  }\n\n  setThreshold(thresholdValue) {\n    this.thresholdValue = thresholdValue;\n  }\n  // FIXME: this might not actually be used\n  setThresholdMax(thresholdValueMax) {\n    this.thresholdValueMax = thresholdValueMax;\n  }\n\n  setInvert(invert) {\n    this.invert = invert;\n  }\n\n  setUseTargetColor(useTargetColor) {\n    this.useTargetColor = useTargetColor;\n  }\n\n  setTargetColor(targetColor, trackingColorMode) {\n    this.useTargetColor = true;\n    this.targetColor = targetColor;\n    this.trackingColorMode = trackingColorMode;\n  }\n\n  setSimplify(simplify) {\n    this.simplify = simplify;\n  }\n\n  draw() {\n    push();\n    noFill();\n    let polylinesSize = this.polylines.length;\n    for (let i = 0; i < polylinesSize; i++) {\n      p5.cv.drawVectors(this.polylines[i]);\n      let boundingRect = this.getBoundingRect(i);\n      rect(\n        boundingRect.x,\n        boundingRect.y,\n        boundingRect.width,\n        boundingRect.height\n      );\n    }\n    pop();\n  }\n\n  resetMinArea() {\n    this.setMinArea(0);\n  }\n\n  resetMaxArea() {\n    this.setMaxArea(Number.POSITIVE_INFINITY);\n  }\n\n  setMinArea(minArea) {\n    this.minArea = minArea;\n    this.maxAreaNorm = false;\n  }\n\n  setMaxArea(maxArea) {\n    this.maxArea = maxArea;\n    this.minAreaNorm = false;\n  }\n\n  setMinAreaRadius(minAreaRadius) {\n    this.minArea = PI * minAreaRadius * minAreaRadius;\n    this.minAreaNorm = false;\n  }\n\n  setMaxAreaRadius(maxAreaRadius) {\n    this.maxArea = PI * maxAreaRadius * maxAreaRadius;\n    this.maxAreaNorm = false;\n  }\n\n  setMinAreaNorm(minAreaNorm) {\n    this.minArea = minAreaNorm;\n    this.minAreaNorm = true;\n  }\n\n  setMaxAreaNorm(maxAreaNorm) {\n    this.maxArea = maxAreaNorm;\n    this.maxAreaNorm = true;\n  }\n}\n\nexport default ContourFinder;\n","import './p5.cv.utils';\nimport './p5.cv.utilities';\n\nimport './p5.cv.helpers';\nimport './p5.cv.wrappers';\n\nimport './p5.cv.tracker';\n\nimport {\n  TrackedObject,\n  Tracker,\n  PointTracker,\n  RectTracker,\n  Follower,\n  RectFollower,\n  PointFollower,\n  TrackerFollower,\n  RectTrackerFollower,\n  PointTrackerFollower,\n} from './p5.cv.tracker';\n\nwindow.Tracker = Tracker;\nwindow.TrackedObject = TrackedObject;\nwindow.RectTracker = RectTracker;\nwindow.PointTracker = PointTracker;\nwindow.Follower = Follower;\nwindow.RectFollower = RectFollower;\nwindow.PointFollower = PointFollower;\nwindow.TrackerFollower = TrackerFollower;\nwindow.RectTrackerFollower = RectTrackerFollower;\nwindow.PointTrackerFollower = PointTrackerFollower;\n\nimport RunningBackground from './p5.cv.running_background';\n\nwindow.RunningBackground = RunningBackground;\n\nimport ObjectFinder from './p5.cv.object_finder';\n\nwindow.ObjectFinder = ObjectFinder;\n\nimport { Flow, FlowPyrLK, FlowFarneback, OFlow, Graph } from './p5.cv.flow';\n\nwindow.Flow = Flow;\nwindow.FlowPyrLK = FlowPyrLK;\nwindow.FlowFarneback = FlowFarneback;\nwindow.OFlow = OFlow;\nwindow.Graph = Graph;\n\nimport './p5.cv.contour_finder';\nimport ContourFinder from './p5.cv.contour_finder';\n\nwindow.ContourFinder = ContourFinder;\n"],"sourceRoot":""}